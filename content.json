{"meta":{"title":"蝉3301","subtitle":null,"description":"好少年光芒万丈","author":"蝉3301","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-01-30T07:26:53.599Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-01-18T07:50:17.467Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-01-30T04:52:42.221Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"顶！d=====(￣▽￣*)b","keywords":"顶！d=====(￣▽￣*)b"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-17T06:40:30.292Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"group: 个人项目desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt;items: url: https://shino.cc/fgvfimg: https://cloud.moezx.cc/Picture/svg/landscape/fields.svgname: Googledesc: Google 镜像 url: https://shino.cc/fgvfimg: https://cloud.moezx.cc/Picture/svg/landscape/fields.svgname: Googledesc: Google 镜像","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"","date":"2020-01-30T04:43:10.195Z","updated":"2019-12-04T06:57:33.070Z","comments":true,"path":"tags/随笔/hello-world.html","permalink":"/tags/随笔/hello-world.html","excerpt":"","text":"fuckyou"}],"posts":[{"title":"逆向杂项","slug":"re/逆向杂项","date":"2020-03-17T07:52:44.000Z","updated":"2020-03-17T07:52:59.514Z","comments":true,"path":"2020/03/17/re/逆向杂项/","link":"","permalink":"/2020/03/17/re/逆向杂项/","excerpt":"","text":"在逆向学习里面遇到的一些比较方便的算法啥的，就总结在这里，虽然杂但是应该会有用&lt;(￣▽￣)/ IDA-IDC（自从idapython能用之后，我打算放弃idc了，所以idc到这里就没了，idc确实没有python方便，我认了，来自某高的建议（手动狗头））定义：auto i,j,k;extern outsideGlobal; //引入全局变量声明 常用函数void PatchByte(long addr , long val) 设置虚拟地址addr处的一个字节值，PatchByte可更换为PatchWord，PatchDword设置虚拟地址addr处的2字节和4字节值。 long Byte（long addr） 从虚拟地址addr读取一个字节值，Byte可更换为Word，Dword读取2字节和4字节值。 void Message（string format , …）,在输出窗口打印一条格式化消息。 void print（…），在输出窗口中打印每个参数的字符串表示形式。 long atol（string val），将10进制val转化成对应整数值。 long xtol（string val），将16进制val转化成对应整数值。 long ord（string ch），返回单字符字符串ch的ASCII值。 string Name（long addr），返回与给定地址有关的名称，如果该位置没有名称，则返回空字符串。 string用法和python一样 auto str = “String to slice”; auto s1, s2, s3, s4; s1 = str[7:9]; //&#39;to&#39; s2 = str[ :6]; //&#39;String&#39; s3 = str[10: ]; //&#39;slice&#39; s4 = str[5]; //&#39;g&#39; 上述内容摘抄于Thunder_J的csdn 注意问题里面的语法不支持i+=1;只支持i=i+1；想打印出ascii值，需要的是Message(“%x”,ord(xxx)),必须要有前面的格式化字符，不然只会给你打印出字符来。 ctf实践auto i; for(i=0x40213b;i&gt;=0x402124;i--) { Message((Byte(i)^6)-1); //我发现他自己转成字符串了，真方便O(∩_∩)O~~ } Message(&quot;\\n&quot;) IDA-Python不管怎么样，python牛逼 ea代表地址 一些常规操作，暂时还没咋用到 ①here()==ScreenEA() #打印当前光标标记地址 ②GetDisasm(ea) #打印地址处汇编指令 ③GetMnem(ea) #只打印指令例如mov cmp之类 ④GetOpnd(ea,n) #操作数，rax，rdx之类，n有0,1，分别表这句汇编指令的某个操作数 ⑥SegName(ea) SegStart(ea) SegEnd(ea) #段名称、段初始地址、段结束地址 ⑦for fuc in Functions(): print hex(fuc),GetFunctionName(fuc) //遍历函数 **显示地址处的字节数** Byte() #同理还有word(ea)、Dword(ea)、Qword(ea)、GetFloat(ea)、GetDouble(ea) **patch数据** PatchByte(ea, value)、PatchWord(ea, value)、PatchDword(ea, value) 这里展现一下效果图 实际运用这里先放一个恶意代码里面说的修改call颜色，等以后再放自己实践用到的 from idautils import from idc import heads = Heads(SegStart(ScreenEA()),SegEnd(ScreenEA())) fuc=[] for i in heads: if GetMnem(i) == &quot;call&quot;: fuc.append(i) print(len(fuc)) for i in fuc: SetColor(i,CIC_ITEM,0xc7fdff) C语言常见函数atoi &amp;&amp; _itoaatoi 参数：char 作用：字符串（字符串为char类型）转int型 a=&quot;123&quot;; b=atoi(a); printf(b); 输出：123（且int b=123） atoi有一个特性，遇到非数字就会截止转换，但前面的会转换 _itoa(value,string,radix) 参数value：欲转换的数据。string：目标字符串的地址。radix：转换后的进制数，可以是10进制、16进制等，范围必须在 2-36。 作用：int型转字符串 做了一道功放世界新放的逆向，名称：Mysterious难度不大，想试着直接静态调试，发现卡在了一个函数身上，思路也是卡死了，应该想到这是一道溢出的ida图片分析如下思路想通了很简单，溢出string给到v12、v13、v14，然后string给v10,就是卡在了atoi遇到非数字就截止但前面都会转换的功能上，知道之后，输入122xyz，122给了v10，剩下xyz分别给了v12、v13、v14，得到结果 本内容中的参数摘抄于lanzhihui_的csdn C格式问题1.for循环，想要4个4个的跳，第三部分格式应为i=i+4而不是i+=4，不然会报Missing brace pythonpyton的一些骚姿势（就是简便代码写法）for循环可以写成 [print(i) for i in range(10)] （后面的很多式子都会用到这个） 字符和数组[asc码]的拼接 str+=&quot;&quot;.join([chr(i) for i in (arr)]) a1,a2的快速建立(z3用的比较方便)：[print(&quot;a%d=%d&quot; % (i,arr[i])) for i in range(10)](将arr值分别给a1,a2,a3) 字典的建立个人感觉没啥用，但也算是知识点，就放到这里来 a=[1,2,3];b=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] ddd=zip(a,b) #zip()将a,b打包成元祖，就是1和a一组，2和b一组 dic=dict(ddd) #建立dict字典 dict正常建立：dict={1:&#39;a&#39;,2:&#39;b&#39;} print(dic) 效果图如下这里说一下，我在做ctf移位复原器的时候，想用这个，但发现如果里面dic[]里面的值是一种式子而不是直接的指定字符，就类似与是dic[mov_dic[i+2]]而不是dic[1]返回的类型就会一直是nobetype，什么也没法转换的一种类型，我人都傻了，技能有限，等以后有这个实力了，再继续利用 pe\\elf相关文件处理PE修改OEP这个操作很简单，修改一个值就ok了，可以PE-tools，可以直接二进制编译器，都可，亲测有效 首先自己写了一个c语言脚本做判断，编译出来发现是jump起步，因为用的vs，不过这都无所谓了。我们发现这堆jmp下面就有一堆空代码所以直接利用 空位置写入jmp的机器码，卡了一会，明白了原理，E9是jmp后面四个字节（dword）用来放偏移，上偏就是负数，下偏就是正数，base值是这块指令地址+5，然后根据计算，我们要去0x343，在0x398+5进行改变，既0x39d，然后0x343-0x39d=0xffffffa6,写上去就行，上图末端有展示 然后PE-tools修改oep二进制工具修改oep 最终结果oep都发生了改变","categories":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}]},{"title":"逆向练习","slug":"ctf/逆向练习","date":"2020-03-17T06:38:27.000Z","updated":"2020-03-17T06:38:54.869Z","comments":true,"path":"2020/03/17/ctf/逆向练习/","link":"","permalink":"/2020/03/17/ctf/逆向练习/","excerpt":"","text":"攻防世界————asong今天做了几道攻防世界的逆向题，有一道题比较麻烦，虽然不难，但耗费了不少时间，其中有很多时间是可以节省的，所以这次就把这道题记录下来。 本来打算直接静调出结果，但中间卡在了一个点上，不得不动调，虽然最后发现，动调并没有给多大的帮助0- 0 放到ida，我已经分好了类，首先输入，然后判断一下开头结尾，之后建立一个字典，最后对输入进行算数处理，逻辑很清晰，没有任何阻碍 建立字典里面有个函数说一下，算一个小坑吧，没在这里绊很长时间。首先，他是从that_girl文件里面根据单词出现的频率，每个单词对应相应的出现次数，然后建立了表格，当时我在这里犹豫了一会儿，在这个我标记的case函数里面，他将单词asc改成了相应下标值，我以为需要考虑，可到后来才发现，其实完全不需要考虑他们的位置，只需要记住对应的词频率就ok这里卡了一会的建立词频率的函数图 他在建立函数时，大小写全都放到一个词频数组里面去的，也就是说不区分大小写 然后运算处理也很简单，首先将我们的各个输入的字符，转化成相对应的频率，再位置变换，再移位交换，最后得到结果 python代码如下 flag=&quot;QCTF{&quot; #建立头 #将给的out文件里面的值取出来 fd=open(&quot;out&quot;,&quot;rb&quot;) #这里注意rb取得是数 buf=fd.read(1) arr=[];arr1=[] while(buf): arr.append(ord(buf)) buf=fd.read(1) fd.close() #最后的移位操作 for i in range(len(arr)): if(i): arr1.append(((arr[i]&gt;&gt;3)+((arr[(i-1)]&lt;&lt;5)&amp;0xe0))) else: arr1.append(((arr[i]&gt;&gt;3)+((arr[len(arr)-1]&lt;&lt;5)&amp;0xe0))) #print(arr1) #置换操作 shun=[22,0,6,2,30,24,9,1,21,7,18,10,8,12,17,23,13,4,3,14,19,11,20,16,15,5,25,36,27,28,29,37,31,32,33,26,34,35] #这个库之前找错了。。。。。。。。卡了很久，我太蠢了_(:з」∠)_ #置换算法1————暴力循环算法 for j in range(37): #因为是一个循环置换，所以让他循环一整个次数，就能回到最初点 i=0 p=arr1[0] while(shun[i]): arr1[i] = arr1[shun[i]] i=shun[i] arr1[i]=p #print(arr1) #置换算法2————逆向算法 j=1 p=arr1[j] for i in range(37): #这个就是倒回去一个一个找 arr1[j]=arr1[shun.index(j)] j=shun.index(j) arr1[j]=p #查找词频 （这里我没用python的dict字典方法，我感觉有点麻烦，还要用到zip函数，这里我建立了两个匹配数组，一样可以实现，个人认为dict也是建立了两个数组emmmmmmmm） dic=&quot;abcdefghijklmnopqrstuvwxyz_\\&#39;\\n &quot; #第一个字符串数组 arr0=[0]*len(dic) fw=open(&quot;that_girl&quot;,&quot;r&quot;) buf=fw.read(1) while(buf): arr0[dic.index(buf.lower())]+=1 #第二个词频数组 buf = fw.read(1) fw.close() #出结果 for i in range(len(arr1)): flag+=dic[arr0.index(arr1[i])] #根据词频去查之前的字典就得到相应的flag flag+=&quot;}&quot; print(flag) 最后祭奠一下卡了半天出错的地方的地方，这里他因为第二个数是0，所以出现了align8（意思是8个0）这个不合理的玩意 _ (:з」∠) _ _ (:з」∠) _ ，没有看到，所以没找到数组里的0，还以为逻辑有错，_ (:з」∠) _卡时候的心态爆炸，发现之后更心态爆炸align8图d键之后的图 可见有时候看到数据连在一起，先d一d是一个好习惯，_ (:з」∠) _（一种植物） 攻防世界————testre（西湖论剑预选赛）首先这道题是base58，俺看出来了它是一个进制转换的函数，但是原理搞了半天也没搞懂，还是算法基础太差，唉，不过虽然思考的时间很久，但最后自己有了一个很明确很好的理解思路，我感觉这也算是有收获，也算是一种成功吧，嘿嘿O(∩_∩)O~ 这个题就是一个base58的加密解密，base58和base64不同的地方是，base58是通过大进制转换，将其他进制转化成58进制，而base64,32,16都是通过2进制位数8位变6位实现的，所以这段代码就是一个进制转换代码，其中有很多混淆迷惑的部分，我们这里就只说在ida分析出来的这个进制算法。 接下来就来分析一下他的进制换算的算法思路吧~~~ ida中的核心算法图（横线是作用代码，未标横线便是混淆代码） v21是我们输入的值；v11是输出数组循环方式：外循环：输入字符循环内循环：每一个字符做进制运算，先%再\\一直到为0为止，然后分别赋到v11的各个数组里面去 开始我按照算法进行推理，但发现如果直接计算，是看不出什么规律的甚至越看越乱，一直到我在纸做了一下推理，才发现原理很简单。首先，我们回顾一下，十六进制0xabcd转十进制，首先要得到十进制末尾，很简单0xabcd%10，我做了一下实践，求余符合分配率，所以我可以分解成 0xa000 % 10 + 0xb00 % 10 + 0xc0 % 10 + 0xd % 10，然后想得到倒数第二位，那么就是0xabcd \\ 10 == X1,再让 X1 % 10，以此类推，怎么样是不是跟我们的上面的式子很是类似？接下来，回到我们的58进制 用十六进制转58进制，要注意的一个问题是，这里我们的十六进制是按照两个字节为一个整体（因为我们输入的字符asc是word型的，所以就按照word进行计算），其实可以说是256进制，我们就姑且称之为双十六进制，然后进行计算。假设我们输入值为0xabcd，按照算法逻辑，它先是进来0xab，V11[22] = 0xab % 58 ，然后的整除放到一边，我们先跳出第一层for循环，看下一个for循环，进来v21=0xcd 这时再一次计算 V11[22] = ((V11[22] &lt;&lt; 8) + 0xcd) % 58，然后得出58进制的末尾 这里不要直接算，把它拆分成如下 (((0xab % 58) &lt;&lt; 8) + 0xcd ) % 58 =((0xab00 % 58) + 0xcd ) % 58 =0xab00 % 58 +0xcd % 58 #(这里已经和我们上面十六进制转十进制完全一致了，下面更清晰一点) =0xabcd % 58 ps：公式用到的原理a % b &lt;&lt; 8 == a &lt;&lt; 8 % b ===== a % b == a00 % b (俺感觉是交换律)a % b % b = a % b 到这里就很清楚了，然后就是整除，再给第二位，之后根据下标对应字符，balabala的，就不多解释了，最后放一下我自己写的base58的py def str_hex(a): return &quot;&quot;.join([hex(ord(a[i])).replace(&quot;0x&quot;,&quot;&quot;) for i in range(len(a))]) #字符串转16进制 def encode_58(a): #加密 c=&quot;&quot; while(a!=0): c=dic[a%58]+c #取末尾 a=a//58 #整除进位 return c def decode_58(a): c=0 for i in range(len(a)): c+=pow(58,i)*dic.index(a[len(a)-i-1]) #解密这里我换了个方法，跟之前不一样了，因为从头直接翻译字符串有时候会出错。他的第一位可能是没用的，所以我们从最后一位开始就是最好的选择 out=&quot;&quot;;div=c while(div&gt;0): div, mod = divmod(div, 256);out=chr(mod)+out return out def hex_str(a): return &#39;&#39;.join([chr(int(a[i:i+2],16)) for i in range(len(a)-2,-1,-2)]) #16进制转字符串 print() input_en=&quot;flag{63510cf7-2b80-45e1-a186-21234897e5cd}&quot; input_de=&quot;BiJZHKtNhHyDe8kSF878CyFgq7h44x1MqUEXiUFJW3gRfQX1MjePwuKHB8&quot; dic=&quot;ABCDEFGHJKLMNPQRSTUVWXYZ123456789abcdefghijkmnopqrstuvwxyz&quot; #表 output=encode_58(int(str_hex(input_en),16)) print(&quot;encode ========&gt; &quot;,output) output=decode_58(input_de) print(&quot;decode ========&gt; &quot;,output) 效果图 从不同的思维方向去看待问题，问题便会得到解决，这次学习有很大的帮助，继续努力O(∩_∩)O~ #攻防世界————echo-server（XCTF 3rd-NJCTF-2017）花指令的简单去除，学习一下，深入学习将会在null比赛的逆向的wp中写出，这道题简单的介绍一下一些小的花指令，首先ida分析看到f5的一些不正常表现可以分析出来有花，去花 花简单来说就是junk_data，做一些无意义的汇编操作，并且让ida反汇编失败，这里因为花很简单，所以我们直接手动patch就行了，看到一些奇怪的汇编指令，比如突然jmp，毫无意义的地址，clc等等，都可以对其进行重组，以下是patch点。这里会是一个call loc，nop e8，后面的数c成代码下面的图同理，那个F1@g字符串是key，千万别nop 最后效果图 然后逻辑就很简单了简单的异或，这里就不说了，只是说一下花，就不浪费时间做异或练习了","categories":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}]},{"title":"poc脚本研究报告","slug":"cve/poc脚本研究报告","date":"2020-03-10T03:32:28.000Z","updated":"2020-03-17T08:12:49.216Z","comments":true,"path":"2020/03/10/cve/poc脚本研究报告/","link":"","permalink":"/2020/03/10/cve/poc脚本研究报告/","excerpt":"","text":"和hr作了约定一个星期学习POC脚本，这里放到博客里来进行记录，个人理解POC脚本实际上也是漏洞的复现，正好最近自己的移动安全作业要复现一个cve漏洞，所以就直接把他们联系到一起吧。 概念名称：POC全称：Proof of Concept（观点验证程序）安全范围：漏洞复现，实现成功利用的脚本","categories":[{"name":"漏洞","slug":"漏洞","permalink":"/categories/漏洞/"}],"tags":[],"keywords":[{"name":"漏洞","slug":"漏洞","permalink":"/categories/漏洞/"}]},{"title":"抗疫赛ctf","slug":"ctf/抗疫比赛","date":"2020-03-10T03:30:38.000Z","updated":"2020-03-19T03:55:34.481Z","comments":true,"path":"2020/03/10/ctf/抗疫比赛/","link":"","permalink":"/2020/03/10/ctf/抗疫比赛/","excerpt":"","text":"这次比赛的质量挺高的，除了那个出错了的fxck，昨天纠结了一下午，后来程序更新也没通知，我是真的想日穿出题者难受，还有一个线性移位寄存器的题，后面我就等着wp自己再去复现一下，那一个我是真的没想出来 #天津垓 扔到ida里面分析，这里是第一个关键函数，按照他的指令就是把我们输入的值和Rising_Hopper!字符串做与和或的操作得出来的值和下面的值比对逆出字符串Caucasus@s_ability，显然不是flag在观察函数时，发现第二个关键函数对一大批数据进行了异或处理，异或字符串就是我们刚逆出来的Caucasus@s_ability，然后output脚本（这里可以直接ida复刻，但是也放出python的方法） ttt=”Caucasus@s_ability” f=open(“ppp”,”rb”) f1=open(“flag”,”wb”) p=1;i=0;p1=1 while(p1): p1=f.read(1) p=int.from_bytes(p1,byteorder=’big’,signed=False) if(i&gt;=0xc4d and i&lt;=0xc4d+0x41e): n = p ^ ord(ttt[(i - 0xc4d) % 18]) f1.write(n.to_bytes(length=1,byteorder=’big’,signed=False)) else: f1.write(bytes(p1)) i += 1然后key2就出来了，比对函数，最后按照逻辑逆出来就行，就一个计算逻辑脚本： res=[0x1EA272,0x206FC4,0x1D2203,2027349,2421009,1653372,2047032,2184813,2302911,2263545,1909251,2165130,1968300,2243862,2066715,2322594,1987983,2243862,1869885,2066715,2263545,1869885,964467,944784,944784,944784,728271,1869885,2263545,2283228,2243862,2184813,2165130,2027349,1987983,2243862,1869885,2283228,2047032,1909251,2165130,1869885,2401326,1987983,2243862,2184813,885735,2184813,2165130,1987983,2460375] for i in range(len(res)): print(chr(res[i]//0x4ce3),end=’’)得到flag 后来还遇到了一个base58出错的题，自闭了一个下午，难受，不过后来发现自己的base58脚本写的有些问题，也算是有一小点点的补偿吧。。还有一个虚拟机的，这里就不说了，就是麻烦，其实逻辑很简单。然后等我更新那个寄存器吧 gatesXgame放上官方wp：null指针放上我的朋友的wp：高高有话说 这道题的答题思路就是一个去花，然后走迷宫，其中新颖的点就是每走一步就换更换系统框架，在x86和64之间轮换跳转，这里我就直接搬来官方wp给的两个花结构 #define JUNK2(idx) __asm{ \\ __asm call next1_junk2_##idx \\ __asm __emit 0x77 \\ __asm jmp next_junk2_##idx \\ __asm __emit 0x88 \\ __asm next1_junk2_##idx: \\ __asm add dword ptr ss:[esp], 1 \\ __asm ret \\ __asm next_junk2_##idx: \\ } #define JUNK1(idx) __asm{\\ __asm jmp jlabel##idx \\ __asm __emit 0x88 \\ __asm jlabel_##idx : \\ __asm ret \\ __asm __emit 0xba \\ __asm jlabel##idx : \\ __asm call jlabel_##idx \\ } 可以自己慢慢去patch，然后我自己写了一个通用的patch脚本，以后只要遇到是有结构性的花指令，都可以用这个脚本来patch，刚patch出来的时候我的心情是无比激动的，呃啊啊啊啊啊！总算patch成了！下面是脚本 h1=[0xEB,0x03,0x88,0xC3,0xBA,0xE8,0xF9,0xFF,0xFF,0xFF] #花结构 h2=[0xE8,0x04,0x00,0x00,0x00,0x77,0xEB,0x07,0x88,0x36,0x83,0x04,0x24,0x01,0xC3] data=[] def check(i,rep): #负责数组匹配和patch k=1 while(k&lt;len(rep)): #这里匹配不同就退出来 if data[i+k]!=rep[k]: return 0 k+=1 for j in range(len(rep)): #匹配成功之后这里进行patch data[i+j]=0x90 with open(&quot;123.exe&quot;,&quot;rb&quot;) as f: #打开文件变成数组data a=f.read(1) while(a): data.append(int.from_bytes(a,byteorder=&#39;little&#39;,signed=False)) a=f.read(1) for i in range(len(data)): #进行匹配 if(data[i]==h1[0]): check(i,h1) elif(data[i]==h2[0]): check(i,h2) with open(&quot;1&quot;,&quot;wb&quot;) as fw: #写入 for i in data: fw.write(i.to_bytes(1,byteorder=&#39;little&#39;,signed=False)) 前后效果图未patchpatch后","categories":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}]},{"title":"汇编大学习","slug":"re/汇编学习-逆向","date":"2020-03-03T07:26:57.000Z","updated":"2020-03-03T07:26:59.869Z","comments":true,"path":"2020/03/03/re/汇编学习-逆向/","link":"","permalink":"/2020/03/03/re/汇编学习-逆向/","excerpt":"","text":"汇编的基础不能一蹴而就，一步一步在实践中学习得来的，只有这样知识才能稳定的进到脑子里，在用的时候不会出现短路的情况。（emmmmmmmm，断路更合适一点_ (:з」∠) _） 这里就没有顺序的讲述了，有什么就记什么了，添加个索引到时候自己就可以分类了 函数约定cdecl流程： push参数 call memory_location 调用函数，push EIP，保存当前指令地址，然后修改EIP为指定函数地址 push EBP，保存当前栈底 函数工作（ps：开始头部一般都是，esp=ebp，esp-=xxx） pop EBP pop EIP并跳转（ps：这里相当于ret） 调整之前栈里面保持的参数 流程图如下： 其余约定等待更新，预计三天后 常用指令说明（很常见的不提，这里只提一些关键但不是很普遍的，或者不容易懂得）cmp指令 &amp;&amp; test指令 &amp;&amp; 跳转指令cmp：通过比较两个寄存器设置标志位| cmp dst,src | ZF | CF ||:————–:| :: | :: ||dst=src(重要) | 1 | 0 ||dstsrc | 0 | 0 |所以if(!cmp)是判断字符串是否相同 test：相当于and（一般看ZF） jz，jnz：ZF=1跳；ZF=0跳 ======= je，jnejg，jge：dst&gt;src\\目标操作数大于源操作数\\CF==0跳；jge为大于等于jl，jle：dst&gt;src\\目标操作数小于源操作数\\CF==0跳；jge为小于等于 mul &amp;&amp; div乘除不说，说一下结果保存点，EAX与EDXmul：EAX保存低32位、EDX保存高32位div：EAX保存商、EDX保存余数 格式： mul value；div value； 缓冲区操作指令 &amp;&amp; 重复指令movsx、cmpsx、stosx、scasx（x代表字节大小，可分为b,w,d,q）（这些操作只在EDI、ESI里面执行） movsx：从[ESI]取出字节，交到[EDI]，然后根据DF标志加1或减1（DF=0，+）\\（DF=1，-1）cmpsx：比对[ESI],[EDI]中的字节stosx：将指定字节存入[EDI]scasb：从一串字节中搜索一个值，该值由AL给出，存到[EDI]rep重复指令停止条件rep：ECX为0时循环终止repe、repz：ECX为0 or ZF=0 时循环终止（字符串是否相同）repne、repnz：ECX为0 or ZF=1 时循环终止 组合： rep movsx ：[EDI]=[ESI] 直到ECX=0；———-memcpyrepe cmpsx ：判断？[EDI+i]==[ESI+i] 直到ECX=0 or ≠；———-memcmprepne scasx ：从缓冲区中搜索一个字节 直到ECX=0 or = \\有便存入rep stosx：给定初始值赋给一段缓冲区，[EDI]指向缓冲区地址，AL包含初始值；———-memset","categories":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}]},{"title":"Frida工具的学习","slug":"Frida工具的学习","date":"2020-02-26T03:05:13.000Z","updated":"2020-03-03T07:34:17.166Z","comments":true,"path":"2020/02/26/Frida工具的学习/","link":"","permalink":"/2020/02/26/Frida工具的学习/","excerpt":"","text":"先留着，感觉是一个神器，不过还是尽量懂得原理，不要做脚本小子","categories":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}]},{"title":"linux学习","slug":"linux学习","date":"2020-02-21T01:57:23.000Z","updated":"2020-03-03T07:36:06.709Z","comments":true,"path":"2020/02/21/linux学习/","link":"","permalink":"/2020/02/21/linux学习/","excerpt":"","text":"常用指令ls-a 显示所有文件包括隐藏文件 -l 显示详细信息 -d 查看目录属性 -h 人性化显示文件大小 -i 显示文件名和inode 图片中有一个错误，分组后面还有一个文件大小 目录//cd cd ~ 回家 cd - 回退，去之前去过的一个目录 cd / 进入根目录，比家更彻底 cd .. 回上一个目录 pwd 显示目录路径 //mkdir 新建文件 -p 可以多层建立 //rmdir 删除空目录（必须是空目录） -p 删除子目录如果上一级目录变空则上一级删除 //rm （常用） -r 删除整个目录 -f force强制删除，不用确认 -i 删除前逐一询问 rm -rf / 删光电脑程序（linux从入门到跑路的关键代码） 文件处理//cp 同mv -a 相当于dpr -d 如果是链接文件，复制链接属性 -f 覆盖已存在不给提示 -i 覆盖给提示 -p 额外把修改时间和访问权限复制到文件 -r 目录文件的话，就全都复制 -l 不复制文件，只生成链接 //mv mv [参数] [源文件] [目标文件] -i 询问覆盖 -f 不询问覆盖 //ln 同mv -b 删除覆盖以前的链接 -d 允许超级用户制作目录的硬链接，一般用户建立文件的硬链接 -f 不询问执行 -i 询问执行 -n 符号链接视为一般目录 -s 软连接（符号链接） -v 显示处理过程 linux文件组成 用户数据：用户所有的源数据元数据：包含inode的文件附加数据 软连接与硬链接硬链接：一个inode号对应多个文件名，这些文件为硬链接，一个文件有多个别名 特性： 文件有相同的inode以及data block 只能对已存在文件创建 不能交叉文件系统进行硬链接创建 不可创建目录文件 删除单一不影响其他 软连接：用户数据块存放的内容是另一个文件的路径名指向（windos快捷方式） 特性： 有自己的文件权限与属性 可以对不存在文件创建 可以交叉系统创建 可创建目录文件 创建，i_nlink不增加 删除不影响被指向文件 搜索locate：文件搜索命令 locate [参数] 文件名 -d 指定搜索数据库（默认/var/lib/mlocate.db）（如果数据库没更新，就搜不到新建，更新命令updatedb，较慢） whereis：搜索命令 -b 搜索二进制文件-m 搜索man手册-s 只搜索源代码-f 终止&lt;目录&gt;参数列表-u 搜索不常见记录-l 输出有效查找路径 which：区别于whereis：which可看到文件别名（Ubuntu好像没区别。。） ps：外部命令有使用手册例如ls\\apt（man），内部命令没有例如cd find find [搜索路径] [选型] [文件名]（find / -name install.org） 通配符模糊搜索（*匹配任意数量字符、？匹配一个字符、[]匹配一个中数组内的字符） [选型]-iname：忽略大小写-user：按所有者-root：按无所有者-mtime：几天内修改过的文件、-atime、-ctime-size：文件大小（-size +20k -a -size -50k）-inum：索引号-a -o：逻辑与逻辑或-exec：以;结束，防止歧义一般用”\\;” grep文件中匹配符合字符串 grep [选项] 字符串 文件名 [选项]-i：忽略大小写-v：排除指定字符串-l：列出包含匹配字符串的文件 帮助命令 –help（或 man 例：man ls） 压缩解压缩.gz gzip 源文件-c：保留源文件-r：目录包含文件都压缩-d：解压缩 .bz2 bzip2 源文件-k：保留原文件-d：解压缩 .tar tar [选项]tar -cvf xorr.tar xorr 关机与重启shutdown [选项] 时间-c 取消关机操作-h 关机后停机-r 重启（设置了时间在控制台就被挂起了） halt、poweroff、init 0 cat /etc/inittab 系统启动的默认级别runlevel 显示现在系统的级别logout 退出当前用户 这里有点乱，到时候稍微在整理一下编程###vi","categories":[{"name":"杂","slug":"杂","permalink":"/categories/杂/"}],"tags":[],"keywords":[{"name":"杂","slug":"杂","permalink":"/categories/杂/"}]},{"title":"恶意代码分析-lab-3-4-5","slug":"virus/恶意代码分析-lab3-4-5","date":"2020-02-15T03:26:54.000Z","updated":"2020-03-04T10:42:11.904Z","comments":true,"path":"2020/02/15/virus/恶意代码分析-lab3-4-5/","link":"","permalink":"/2020/02/15/virus/恶意代码分析-lab3-4-5/","excerpt":"","text":"这次把实验3-4-5写到一起，感觉这样更好看一些 []~(￣▽￣)~* lab3-1分析首先，加壳，由于这一章是动态分析，所以不脱壳直接动态分析 通过procmon可以得到一些库出去基础，额外有ntdll.dll、wow64.dll 字符串中有如下图 可能修改了注册表使其可以开机自动运行，并且运行了一个vmx32to64.exe的程序 不过这个文件应该是挂了，我的win7系统上运行不起来，毕竟这本书是在xp的基础上讲得，不过我发现如果用ida可以直接判断出很多有用的信息 一些知识： HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run procmon筛选会出现的典型噪声（原理：随机数发生器的种子会有软件在注册表上不断更新） HKML\\SOFTWARE\\Microsoft\\Cryptography\\RNG\\Seed 之后换了在xp机上实验，果然是版本问题，看来病毒太老也是不行 0-0 procmon选出筛选条件 得到相关数据 这里可以得出上述中的vmx32to64.exe写进了system32的文件里，seed是噪声，第二项表明建立了一个开机启动项 procex可以观察正在运行中的lab03-1.exe的一些信息 导入的一些dll文件 ws2_32.dll: Windows Sockets应用程序接口， 用于支持Internet和网络应用程序。 //一般就是允许恶意软件联网（还有wshtcpip.dll）建立了一个互斥量WinVMX32（互斥量：同一时间保证只有一个恶意代码在运行） 同时在注册表设置了开机自启动 第一个实例就是练习试用一下各个工具 3-2样本名称：Lab03-02.dll样本大小：24065bytes样本类型：DLL 32bit Portable executable for 80386 (PE)MD5：84882C9D43E23D63B82004FAE74EBB61 分析环境：Windows7 64虚拟机调试工具：PE_Stu、IDA 直接一个dll文件，之前说过可以用rundll32.dll直接运行一下，刚开始踩坑了，应该先去查看他的输出表，之后再去根据输出表的函数输入对应的cmd命令 cmd命令: rundll32.exe Lab03-02.dll,installA 看到ServcieMain说明恶意代码要安装一个服务 查看import库 CreateServiceA,RegSetValueExA等（ADVAPI32.dll）表明里面有服务操作,且有注册表值修改WS2_32.dll：联网，其中有关于http的相关函数说明使用了http","categories":[{"name":"virus","slug":"virus","permalink":"/categories/virus/"}],"tags":[],"keywords":[{"name":"virus","slug":"virus","permalink":"/categories/virus/"}]},{"title":"PE——ELF文件格式","slug":"re/PE-ELF文件结构","date":"2020-02-14T03:03:00.000Z","updated":"2020-03-03T07:35:41.479Z","comments":true,"path":"2020/02/14/re/PE-ELF文件结构/","link":"","permalink":"/2020/02/14/re/PE-ELF文件结构/","excerpt":"","text":"之前老师给了任务，同时自己也学习了很多，所以在这里写一下关于ELF和PE的文件格式的一些学习 ELF文件格式先写出readelf和hexdump的一些用法 readelf： -a 全部展现 -h ELF文件头 -l 程序头 -S 节区头（注意大写） -x index 节区中每个分区的十六进制 hexdump: -s 从某个地址开始（可以用0x） -n 截取大小 -C 标准十六进制格式输出 首先观察一下特德文件大体结构，如下图，左边是在磁盘中的结构，右图是运行时的结构，磁盘中分的节区，运行中的分的是段 接下来介绍一下刚才图中的三个索引表 ELF头部(ELF_Header): 每个ELF文件都必须存在一个ELF_Header,这里存放了很多重要的信息用来描述整个文件的组织,如: 版本信息,入口信息,偏移信息等。程序执行也必须依靠其提供的信息。 程序头部表(Program_Header_Table): 可选的一个表，用于告诉系统如何在内存中创建映像,在图中也可以看出来,有程序头部表才有段,有段就必须有程序头部表。其中存放各个段的基本信息(包括地址指针)。 节区头部表(Section_Header_Table): 类似与Program_Header_Table,但与其相对应的是节区(Section)。 ELF 头部：设置一个elf文件常用的数据格式（此为32位） //ELF Header结构体 #define EI_NIDENT 16 typedef struct { unsigned char e_ident[EI_NIDENT]; 一个数组含有magic，大小端绪、32\\64位，文件版本、ABI等信息 ELF32_Half e_type; 文件类型：可重定向（.O）、可执行、共享目标文件（.so） ELF32_Half e_machine; cpu架构 ELF32_Word e_version; 文件版本 ELF32__Addr e_entry; 代码入口地址 ELF32_Off e_phoff; 程序头偏移（==ELF头size） ELF32_Off e_shoff; 节区头偏移 ELF32_Word e_flags; 暂无0 -0 ELF32_Half e_ehsize; ELF头size ELF32_Half e_phentsize; 程序头各分段size ELF32_Half e_phnum; 程序头中分段数量 ELF32_Half e_shentsize; 节区头各节区size ELF32_Half e_shnum; 节区头节区数量 ELF32_Half e_shstrndx; 节区名称于节区数组中的下标 }Elf32_Ehdr; 下图为ida与linux中readelf图 hex表 其中Relocatable File（.o文件）不需要执行，因此e_entry字段为0，且没有Program Header Table等执行视图 程序头部表： //每个段的结构 typedef struct{ Elf32_Word p_type; 下文有介绍 Elf32_Off p_offset; 段相对于文件的索引地址 Elf32_Addr p_vaddr; 段在内存中的虚拟地址 Elf32_Addr p_paddr; 段的物理地址 Elf32_Word p_filesz; 段在文件中的size Elf32_Word p_memsz; 段在内存中的size Elf32_Word p_flage; 段相关标志(read、write、exec) Elf32_Word p_align; 字节对齐 p_vaddr 和 p_offset 对 p_align 取模后应该等于0。 } Elf32_phdr; p_type 声明此段的作用类型 PT_INTERP:共享库的加载器执行外部库搜索和加载的程序称为加载器，elf格式的是ld-linux.so，a.out格式是ld.so。而由于加载器可能有多种实现，也可能有多个版本，所以每个二进制文件中都需要指明使用哪个加载器，指明使用哪个加载器的功能就是用segment实现的，这种segment就是PT_INTERP类型。 PT_DYNAMIC：记录了elf执行需要的库 PT_LOAD：真正的程序存储的地方。这个构成了程序的主体。 此段文字摘抄于broler作者的csdn博客，一下为其链接 https://blog.csdn.net/ljy1988123/article/details/50404642 以下为ida与readelf读出的程序头部表以及hex图 节区头部表//每个节区的结构 typedef struct{ Elf32_Word sh_name; 节区名称 Elf32_Word sh_type; 节区格式 Elf32_Word sh_flags; 节区相关标志(read、write、exec) Elf32_Addr sh_addr; 地址 Elf32_Off sh_offset; 偏移 Elf32_Word sh_size; 大小 Elf32_Word sh_link; 给出此节区需要用到的索引成员链接（比如.dynsym---&gt;.dynstr） Elf32_Word sh_info; 此成员给出的一些附加信息（与type有关） Elf32_Word sh_addralign; 字节对齐 Elf32_Word sh_entsize; 节区中每条ent的size（若节区里面又分成了多条ent） }Elf32_Shdr; sh_type 系统节区的功能属性 动态连接过程所需要的信息由.dynsym、.dynstr、.interp、.hash、.dynamic、.rel、.rela、.got、.plt 等节提供 .init 和.fini 节用于进程的初始化和终止过程。 以点号”.”为前缀的节名字是为系统保留的 节区功能属性及下面文字摘抄于广敏作者的csdn博客，以下为其链接地址 https://blog.csdn.net/u011298001/article/details/84862565 以下为readelf读出的节区头部表和section到segment的映射表 elf中重要的功能重定位 这里给重定位留着位置，现在总是半懂不懂的，先留着等过以后找时间补充 其上内容借鉴于各大佬的博客，以下附上链接地址 https://blog.csdn.net/u011298001/article/details/84862565https://blog.csdn.net/ljy1988123/article/details/50404642https://www.52pojie.cn/thread-591986-1-1.html PE文件格式个人感觉PE文件结构看上去比ELF要友好那么一点点（可能是因为做windows恶意代码分析的缘故吧0 -0） 废话不多说，先上一个PE文件结构的图 此图为逆向工程核心原理上的结构图左边是磁盘上的结构右边是运行时映射到内存上的结构 首先还是从“头”开始 PE文件头dos头（含dos存根）比较简单，这里就不列出全部了，我们只需要关注两个区域，图片在下面，在下一个是在PE_stu里面展示的，大致了解一下情况 e_magic：常数，文本值为MZe_lfanew：NT头的偏移又或者说是dos头的大小 这里他的dos存根就是展示一下DOS操作系统不能运行，然后退出这个程序，算是一个小小的彩蛋吧，哈哈 NT头这个头就比较重要了，他由两部分组成，一个是文件头一个是可选头，NT头是头里面最大的头 typedef struct _IMAGE_NT_HEADERS { DWORD Signature; 签名PE IMAGE_FILE_HEADER FileHeader; 文件头 IMAGE_OPTIONAL_HEADER32 OptionalHeader; 可选头 } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 文件头 typedef struct _IMAGE_FILE_HEADER { WORD Machine; 文件运行的平台，比如x86，x86_64 WORD NumberOfSections; 节区数目 DWORD TimeDateStamp; 时间戳，换算可以参考病毒分析的lab1 DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; 可选头大小 WORD Characteristics; 文件的属性 } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; Machine Characteristics 这里我们只需要记住一些重要的就行比如0x0002（可执行）、0x0100（32位）、0x1000（系统文件）、0x2000（dll文件） 图片来源于adam001521的博客 可选头 typedef struct _IMAGE_OPTIONAL_HEADER { WORD Magic; 表明可选头类型（0x10b 32PE、0x20b 64PE） BYTE MajorLinkerVersion; 链接器的版本号 BYTE MinorLinkerVersion; DWORD SizeOfCode; 代码段的总长度 DWORD SizeOfInitializedData; 初始化数据长度 DWORD SizeOfUninitializedData; 未初始化数据长度 DWORD AddressOfEntryPoint; 程序入口RVA exe的main、dll的DllMain、驱动的DriverEntry DWORD BaseOfCode; 代码段起始的RVA DWORD BaseOfData; 数据段起始的RVA DWORD ImageBase; 映像（加载到内存上的）基地址 DWORD SectionAlignment; 内存中节区地址起始最小值，比如0x1000则每个节的起始地址低12位都是0 DWORD FileAlignment; 文件中对齐值，同上文 WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; 保留必须为0 DWORD SizeOfImage; 映射到内存的映像的大小 DWORD SizeOfHeaders; 头的大小，以FileAlignment对齐的 DWORD CheckSum; WORD Subsystem; 区分是系统文件还是可执行文件 WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; 数据目录数目，下面的数据目录是个数组，里面存着各种重要的数据的RVA和Size IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; Subsystem 值 含 义 备 注 1 Driver文件 系统驱动（如：ntfs.sys） 2 GUI文件 窗口应用程序（如：notepad.exe） 3 CUI文件 cmd程序（如：cmd.exe） DataDirectory（结构就不放了，就一个RVA一个size） 重要的是import[1]、export[0]、resource[2]、TLS[9] 最后说明一下其十六进制数据 节区头typedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; 节表名称,如“.text” union { DWORD PhysicalAddress; 磁盘中的地址（物理地址） DWORD VirtualSize; 虚拟大小（节区映像大小） }Misc; DWORD VirtualAddress; 虚拟地址 DWORD SizeOfRawData; 磁盘中节区大小 DWORD PointerToRawData; 磁盘中节区偏移 DWORD PointerToRelocations; 在OBJ文件中使用，重定位的偏移 DWORD PointerToLinenumbers; 行号表的偏移（供调试使用地） WORD NumberOfRelocations; 在OBJ文件中使用，重定位项数目 WORD NumberOfLinenumbers; 行号表中行号的数目 DWORD Characteristics; 节属性如可读，可写，可执行等 } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; Characteristics 图片来源于qintangtao的博客园 十六进制图 import导入export导出重定位延迟重定位loading。。。。。。 感谢adam001521师傅提供的素材qintangtao师傅提供的图片","categories":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}]},{"title":"恶意代码分析-lab1","slug":"virus/恶意代码分析-lab1","date":"2020-02-13T03:03:00.000Z","updated":"2020-03-04T10:42:17.639Z","comments":true,"path":"2020/02/13/virus/恶意代码分析-lab1/","link":"","permalink":"/2020/02/13/virus/恶意代码分析-lab1/","excerpt":"","text":"之前学了PE结构，dll注入以及一些相关的逆向知识后，正式开始恶意代码分析的学习，先从这本恶意代码分析开始，争取一个星期把它消化完。 lab1-1virustotal.com可以直接上传文件查看分析报告，会对比其中相关的哈希值，查找库是否此文件有问题第一章的问题稍微都简单一些，这里就简单带过分析：有病毒特征，特征如下从PE-stu查看文件可知，时间戳的二进制是0x4d0e2fd3然后就是转换成时间的过程，这里应该有更简单的方法，但是我想学习并练习一下C++的使用，所以写了一个程序 #include &lt;stdio.h&gt; #include &lt;ctime&gt; using namespace std; void unix2time(int n, char strTime[], int buflen) { struct tm tm = *localtime((time_t *)&amp;n); //这里的定义不太清楚，我傻了 strftime(strTime, buflen-1, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;tm); strTime[buflen-1] = &#39;\\0&#39;; } int main(void) { int n; char strTime[100]={0}; scanf(&quot;%p&quot;,&amp;n); //输入十六进制，记住p，记住是&amp;n不是n unix2time(n,strTime,sizeof(strTime)); printf(&quot;%s&quot;, strTime); } exe时间：2010-12-20 00:16:19dll时间：2010-12-20 00:16:38有效字符串过少，但import库里面的函数数目正常，查找字符串也是正常，exe程序应该是未混淆未加壳copy find creat file可以看出创建并查找了某个文件，可能是进行了电脑上系统文件的替换中毒情况是屏幕背景变黑，应该是改变屏幕程序的文件了 dll文件里有CreateProcess和Sleep，同时import导入了WS2_32.dll的库的一些函数，其中一些函数提供了联网的功能 从dll文件中可以看到一个ip地址，以为是教学使用所以是具体的，真正恶意代码一般是路由的公网ip 文件目的：dll是一个后门，exe用来安装运行dll文件的 其中exec与sleep结合使用，需要特别关注，可能是通过网络给后门程序传达命令的 ##lab1-2分析：有病毒特征，加upx壳，尝试脱壳，esp定律，走到ep，dump出来就行 查看导入函数：StartServiceCtrlDispatcherA、CreateServiceA、OpenSCManagerA（advapi32.dll） StartServiceCtrlDispatcherA：将服务进程的主线程连接到服务控制管理器，这使得线程成为调用进程的服务控制调度程序线程。 CreateThread（kernal.dll） InternetOpenUrlA（wininet.dll） 访问相关网络资源 总结：创建一个线程，创建新的服务并控制 ##lab1-3分析：有病毒特征，加了壳，是FSG壳，但是看开头三个地址就知道那是最终的目标，然后f8下去找到的入口，参考图如下 有两个新库oleaut32.dll、ole32 CoCreateInstance（ole32）SysAllocString（oleaut32.dll） 最终感染就是打开一个网站http://www.malwareanalysisbook.com/ad.html ##lab1-4分析：有病毒特征，无壳未混淆，输入库结构清晰 有create、movefile之类的函数，还有openprocess，loadresource的函数 GetWindowsDirectoryA：得到系统文件目录 通过分析好像是修改了一个wupdmgr的程序，网络查阅发现是windows更新的程序（可删除），但是有病毒伪造的可能，所以确定了，新建了wupdmgr文件，植入病毒 这里书本给了提示，通过resource hacker可以发现此文件在PE文件里藏了一个可执行exe程序 将exe程序dump出来之后可以发现 __imp_URLDownloadToFileA、WinExec远程下载程序并执行，就此初步目的分析结束 lab1的练习结束，发现答案解析比我想象的要简单，需要加快速度，奥利给！！","categories":[{"name":"virus","slug":"virus","permalink":"/categories/virus/"}],"tags":[],"keywords":[{"name":"virus","slug":"virus","permalink":"/categories/virus/"}]},{"title":"博客搭建自学注意事项","slug":"博客搭建自学注意事项","date":"2020-01-29T11:45:40.000Z","updated":"2020-03-03T13:21:28.562Z","comments":true,"path":"2020/01/29/博客搭建自学注意事项/","link":"","permalink":"/2020/01/29/博客搭建自学注意事项/","excerpt":"","text":"大体操作在\\hexo的_config.yml里面有 description: 好少年光芒万丈 keywords: author: 蝉3301 language: zh-cn timezone: #这里注意deploy和backup的格式即可 deploy: type: git repo: github: git@github.com:shijingtian/shijingtian.github.io.git # github: https://github.com/honjun/honjun.github.io.git # coding: https://git.coding.net/hojun/hojun.git branch: master # backup backup: type: git message: backup my blog of https://shijingtian.github.io/ repository: github: https://github.com/honjun/honjun.github.io.git/tree/back #coding: https://git.coding.net/hojun/hojun.git,backup 在\\themes的_config.yml里面有 # site name prefixName: 阿天 siteName: 蝉3301 # favicon and site master avatar favicon: /images/GhostSoul.ico avatar: /img/custom/avatar.jpg url: https://shijingtian.github.io description: T R Y cdn: https://cdn.jsdelivr.net/gh/shijingtian/cdn@master pjax: 1 notice: PE结构研读中(IAT、EAT) lazyloadImg: https://cdn.jsdelivr.net/gh/shijingtian/cdn@119/img/loader/orange.progress-bar-stripe-loader.svg 这里要哪个就用哪个就行，想要增加后面的zh-cn文件里面添加一下就行，后面背景什么的都一样不再赘余 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, # 生活: {path: /categories/生活/, fa: fa-file-text-o }, # 资源: {path: /categories/资源/, fa: fa-cloud-download }, # 随想: {path: /categories/随想/, fa: fa-commenting-o }, # 转载: {path: /categories/转载/, fa: fa-book } 一些代码更新中用到的代码 更新hexo到github并发布 hexo -g &amp;&amp; -d 更新cdn git add . git commit -m &quot;update&quot; git push 建立新的md文件 hexo new xx.md 期间遇到的坑当时有一个social图标，wechat会有相应二维码展示，我qq用的比较多，想在qq上也用上二维码，但发现仅仅改变_config.yml的代码让其和wechat一样，发现不行,没有效果，然后就是个人的操作了。 首先去网页源码去观察到了wechat的不同之处 li class=&quot;wechat&quot; a href=&quot;/#&quot; img src=&quot;https://cdn.jsdelivr.net/gh/shijingtian/cdn@master/img/social/wechat.png&quot; /a div class=&quot;wechatInner&quot; img src=&quot;https://cdn.jsdelivr.net/gh/shijingtian/cdn@master/img/custom/wechat_q.png&quot; /div /li 有一个wechatInner，大概是一个已经标定好的类，于是在headertop.ejs里面找到了他，看了看语法，根据模样我在里面加了一个筛选条件 % if (i == &#39;wechat&#39; || i == &#39;tencent&#39;) {% % if(i == 'wechat') {% li class=\"wechat\" a href=\"%= theme.social[i].url%\" img src=\"%- (theme.cdn || '') + theme.social[i].img%\" /a div class=\"wechatInner\" img src=\"%- (theme.cdn || '') + theme.social[i].qrcode%\" /div /li %} else {% li class=&quot;tencent&quot; a href=&quot;%= theme.social[i].url%&quot; img src=&quot;%- (theme.cdn || &#39;&#39;) + theme.social[i].img%&quot; /a div class=&quot;tencentInner&quot; img src=&quot;%- (theme.cdn || &#39;&#39;) + theme.social[i].qrcode%&quot; /div /li % } % % } else { % li a href=&quot;%= theme.social[i].url%&quot; target=&quot;_blank&quot; class=&quot;social-github&quot; title=&quot;%- i %&quot; img src=&quot;%- (theme.cdn || &#39;&#39;) + theme.social[i].img%&quot; /a /li % } % 运行发现还是不行，请教大神之后，明白还要在style.css文件里面添加相应的类别才行，添加如下（和wechat一致就可以） .tencent { width:35px; height:35px; position:relative } .tencentInner img { border-radius:0; width:121px; height:auto; padding:0; background:none } .tencentInner { width:121px; height:121px; padding:10px; background:rgba(0,0,0,.4); top:40px; left:-40px; -webkit-transform:translate3d(0,50px,0); transform:translate3d(0,50px,0); opacity:0 } .tencentInner:before { content:&quot;&quot;; position:absolute; top:-30px; left:50%; margin-left:-15px; border-width:15px; border-style:solid; border-color:transparent transparent rgba(0,0,0,.4) transparent } .tencentInner { position:absolute; border-radius:8px; transition:.7s all ease; -webkit-transition:.7s all ease; -moz-transition:.7s all linear; -o-transition:.7s all ease; -ms-transition:.7s all ease } .tencent:hover .tencentInner { -webkit-transform:translate3d(0,16px,0); transform:translate3d(0,16px,0); opacity:1; visibility:visible } 最后实现效果第一次完整搭建了自己的博客，学到了许多，后面就赶紧把最近学的PE文件格式的学习笔记搭上来。还是需要不断努力，翻滚吧，阿天~~~","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"逆向ctf练习","slug":"ctf/日常逆向ctf练习","date":"2019-12-16T01:07:01.000Z","updated":"2020-03-03T07:35:20.172Z","comments":true,"path":"2019/12/16/ctf/日常逆向ctf练习/","link":"","permalink":"/2019/12/16/ctf/日常逆向ctf练习/","excerpt":"","text":"nctf——HomuraVM虚拟机的题目，只要把每个字符代表的意思读懂就行 MCh: r2=(r1+flag[xxx])-2(r1 &amp; flag[xxx]);(flag+1){mG}: flag[xxx]=r2;r2=0Hv: (flag+1);r2=r1{aG}: r1=0;r2=0[ur]: r1=flag[xxx];flag=0Ov: (flag-1);(r2=r1)[无用]a: r1–;r: r1++;h: (flag+1) 下面是wp def fuc(r1,flag): return (r1 + flag) - 2 * (r1 &amp; flag) order_list1=[&quot;1&quot;,&quot;aaa&quot;,&quot;rr&quot;,&quot;rarara&quot;,&quot;rararrr&quot;,&quot;araraa&quot;,&quot;rararrara&quot;,&quot;rrrarrr&quot;,&quot;aarrarr&quot;,&quot;aaarrar&quot;,&quot;rrrarr&quot;,&quot;aarrraa&quot;,&quot;arraar&quot;,&quot;rrraaarr&quot;,&quot;aaarrrrarr&quot;,&quot;rrrraarrarr&quot;,&quot;rrarra&quot;,&quot;aaraar&quot;,&quot;ovrrarra&quot;,&quot;aarrrar&quot;,&quot;rraarra&quot;,&quot;rrar&quot;,&quot;aarrar&quot;,&quot;rrraar&quot;,&quot;rrrraa&quot;,&quot;rrarra&quot;,&quot;rrrrrr&quot;,&quot;aaaar&quot;,&quot;rraaa&quot;,&quot;aarra&quot;,&quot;rrar&quot;,&quot;aarraa&quot;,&quot;aarrara&quot;,&quot;aarrarar&quot;] end=[27,114,17,118,8,74,126,5,55,124,31,88,104,7,112,7,49,108,4,47,4,105,54,77,127,8,80,12,109,28,127,80,29,96] count=1 flag=[125];tem=[] r1=0;r2=0 out=&quot;&quot; while(count&lt;=34): for i in range(25,126): if(count==1): if (fuc(flag[count-1],i) == end[count - 1]): flag.append(i) out += chr(flag[count]) break else: r_c=order_list1[count-1].count(&#39;r&#39;) a_c=order_list1[count-1].count(&#39;a&#39;) i1=i+r_c-a_c #print(count,flag,end,i1) if(fuc(end[count-2],i1)==end[count-1]): flag.append(i) out+=chr(flag[count]) break count+=1 print(out) easyRE——(忘了那个比赛出的了)很简单的逻辑，判断长度然后judge一下就出来了然后打开judge，有一个sp手段，修复之后，发现什么都不是但观察到，代码下方有许多的数据看到开始发现有一个judge的异或操作，所以理解题目意思，将judge的数据与0xc异或然后得到正常代码，正常运行一下就行（这里注意运行之前先把judge全部变成data，不然会出现代码混乱类似于以下情况） 未转换成data图转换成data图然后就是一个究极简单的异或，做一个简单的题放松一下 a=[102,109,99,100,127,107,55,100,59,86,96,59,110,112] flag=&quot;&quot; for i in range (len(a)): flag+=chr(a[i]^i) print flag blackcase又是一个小小的虚拟机问题，给的txt文件就是一个测试通过后显示里面的文本，没别的大用，主要是第二次输入的password，然后找到相关的op码代表的含义就可以了。 这里是通过我们输入的值，call相关的sub这里就是我们的一些操作根据动调找到八个相关的操作码在这里有一些位置要标记a1 + 665 #类似一个暂时寄存器（设为eax）a1 + 664 #得到下一位输入的值a1 + 8 #得到我们输入的字符串stra1 + 288 #index（下标） 分析函数fuc1: eax=str[index]fuc2: str[index[=eaxfuc3: eax=eax+next_input-33fuc4: eax=eax-next_input+33fuc5: index++fuc6: checkfuc7: index–fuc8: str[index] = input[index+next_input-48]-49fuc9: index=next_input; str[index] = input[index+next_input-48]-49 然后构造opcode序列就好$t/80表示：var = str[0] var = 80var = var - input[2] + 33 = 66str[0] = varindex++ 类似，可构建产生Binggo的opcode序列为 $t/80$C)80$CI80$CX80$Cg80$Cj8处理多余位数 0#J1index– uuuuuuu调用func6 Es $t/80$C)80$CI80$CX80$Cg80$Cj80#J1uuuuuuuEs（因为好长时间了，自己的操作码都忘了，所以这里直接放进大佬的操作） 这里可以多解的，我们不让check做最后一次，我们让check中的else实现，然后打印某一位置的字符，再通过相关操作把该位置的字符改成Binggo也是可以的 网安运维塞——re3（0x27BC86A9）这道题是一个类矩阵乘法，2x2的矩阵进行相乘，首先要求我们输入三个数，然后一个一个检测，每个数进行右移，每进行一次就做一次运算，最后得到一个0x27BC86A9即可这里有两个矩阵，我们称其为q_list1和q_list2,这里我卡了很长时间，本来是想爆破的，但后来发现一直都不行，无奈只好仔细看算法。 我们输入的数转成二进制，每一位都会进行判断，如果是1，那便q_list2=q_list1q_list2，不管是不是1都要进行q_list1=q_list1。 而且再仔细看，q_list2的初值比较特殊，既q_list2[0]*q_list1=q_list1,乘任何数都等于任何数它本身，相当于乘法里的1，而且那么我们可以把最后结果变成这样q_list2=q_list1[0] x q_list[1] x……x q_list[n] q_list[1] = q_list[0]^2(这里指2次方)q_list[2] = q_list[0]^4…q_list[2] = q_list[0]^( 2^(n-1) )最后我们我们就让q_list[0]自乘，一直得到我们想要的值就行，他的自乘次数就是我们想要的值，爆破就完事了 def fff(v27): return (v27 - 666666666 * ((((0x67144772A3C047E5 * v27) &gt;&gt; 64) &gt;&gt; 28) - (v27 &gt;&gt; 63))) def fuc(q_list1, q_list2): #为了加快爆破速度，这里我们把它简化 q_list3 = [[0, 0], [0, 0]] q_list3[0][0] = fff(fff(fff(q_list1[0][0] * q_list2[0][0])) + fff(q_list1[0][1] * q_list2[1][0])) q_list3[0][1] = fff(fff(fff(q_list1[0][0] * q_list2[0][1])) + fff(q_list1[0][1] * q_list2[1][1])) q_list3[1][0] = fff(fff(fff(q_list1[1][0] * q_list2[0][0])) + fff(q_list1[1][1] * q_list2[1][0])) q_list3[1][1] = fff(fff(fff(q_list1[1][0] * q_list2[1][0])) + fff(q_list1[1][1] * q_list2[1][1])) return q_list3 for i in range(pow(2,32)): #这里让他跑就行了，大概20分钟所有数据就都出来了 q_list1=fuc(q_list1,q) #print(i) if(q_list1[0][1]==0x220951BB): print (q_list1) print(i) #print(q_list1) #print (i) 最后得到三批数据，带进去就好了，这里提醒一下，我们出来的次数要加1才是最后的值 blackcase题目大佬地址 https://blog.csdn.net/q1uTruth/article/details/99943837","categories":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2020-03-03T07:36:09.310Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"杂","slug":"杂","permalink":"/categories/杂/"}],"tags":[],"keywords":[{"name":"杂","slug":"杂","permalink":"/categories/杂/"}]}]}